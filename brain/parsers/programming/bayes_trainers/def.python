from base import BaseParser
import re, string, math


class EquationParser(BaseParser):
    """
    brain.parsers.equation
    parser to identify and solve some mathematical equations
    """


    parsedEquation = None
    """ After we've processed the input string from the user, this var will contain the assembled result """


    def __init__(self):
        self.Type = "Equation"
        self.Confidence = 0
    
    
    def isSimpleEquation(self, data):
        """ Seeing if our string only has symbols found in simple math equations """

        rgx = re.compile("""^
           ([()*.\-+0-9^/ ])*
           $""", re.VERBOSE)
           
        match = rgx.match(data)
        
        if match:
            data = self.autoFloat(data)
            self.parsedEquation = self.autoMultiply(data)
            return True
            
        return False
    
    
    def isTextEquation(self, data):
        """ Searching for specific textual markers that can be converted into mathematical operators """
        
        # SQUARE ROOTS
        parsedData = re.compile('SQUARE[ ]{1,}ROOT[ ]{1,}OF[ ]{1,}\d+(\.\d+)?').sub(self.squareRootTextReplace, data)
        
        # Simple Operators
        parsedData = parsedData.replace('TIMES', '*')
        parsedData = parsedData.replace('PLUS', '+')
        parsedData = parsedData.replace('MINUS', '-')
        parsedData = parsedData.replace('DIVIDED BY', '/')
        parsedData = parsedData.replace('DIVIDEDBY', '/')
        
        # Simple Powers
        parsedData = re.compile('[ ]{1,}SQUARED|[ ]{1,}CUBED').sub(self.simplePowerReplace, parsedData)
        
        if parsedData != data:
            parsedData = self.autoFloat(parsedData)
            self.parsedEquation = self.autoMultiply(parsedData)
            return True
        
        return False
    
    
    def simplePowerReplace(self, match):
        """ Converts "SQUARED" and "CUBED" to their proper exponent representation """
        
        myString = match.group()
        
        if (myString.find('SQUARED') != -1):
            myString = '**2'
        elif (myString.find('CUBED') != -1):
            myString = '**3'
        
        return myString
    
    
    def squareRootTextReplace(self, match):
        """ Replaces square root references with math.sqrt """
        
        myString = match.group().replace('SQUARE','')
        myString = myString.replace('ROOT','')
        myString = myString.replace('OF','')
        myString = myString.strip()
        
        myString = 'math.sqrt('+myString+')'
        
        return myString
    

    def autoFloat(self, data):
        """ Makes all digits/decimals into floats so we can do proper math on them without auto-rounding """

        data = re.compile(r'\d+(\.\d+)?').sub(self.floatReplace, data)
        
        return data
        

    def floatReplace(self, match):
        """
        This turns our numbers into floats before we eval the equation.
        This is because 4/5 comes out at 0, etc. Python autorounds...
        """
        string = 'float('+match.group()+')'
        return string
        
    
    def autoMultiply(self, data):
        """ Any back to back parens/floats can be assumed to be multiplication. Adding * operator between them """
        data = string.replace(data, ')float', ')*float')
        data = string.replace(data, ')(', ')*(')
        
        return data


    def checkForSafeEquationString(self):
        """
        Checks to make sure that the equation doesn't contain any unexpected characters
        
        This is pseudo-sanitization. We just make sure that the string has only "safe" characters
        We do this by removing all expected strings, and seeing if we have nothing left.
        """
        equation = self.parsedEquation

        # These are characters or strings that we can use in an equation
        safeStrings = ['math.sqrt', 'float', '(', ')', '*', '+', '-', '/', '.']

        for char in safeStrings:
            equation = string.replace(equation, char, '')

        for num in xrange(10):
            equation = string.replace(equation, str(num), '')

        equation = equation.strip()

        return ('' == equation)

        
    def solveEquation(self):
        """ Evaulates the equation to see if it's solve-able """

        if not self.checkForSafeEquationString():
            return False
        
        try:
            return eval(self.parsedEquation.strip())
        except:
            self.Confidence = 0
            return False
    
    
    def parse(self, data, **kwargs):
        """ Standard parse function for checking if entered string is a mathematical equation """
        
        # Doing some initial data cleanup
        cleanData = string.replace(data.upper(), 'X', '*')
        cleanData = string.replace(cleanData, '^', '**')
        cleanData = string.replace(cleanData, 'THE', '')
        cleanData = cleanData.strip()
        
        # if we just have a digit, we know this isn't an equation
        if (cleanData.isdigit()):
            return self.result(False);
        
        likely = False
        
        if self.isSimpleEquation(cleanData):
            resultType = "Simple"
            likely = True
        
        if self.isTextEquation(cleanData):
            resultType = "Text"
            likely = True
        
        if likely:
            calculated = self.solveEquation()
            if calculated:
                return self.result(True, resultType, 75, calculated)

        return self.result(False)

from base import BaseParser
import string, re

class PhoneParser(BaseParser):

    def __init__(self):
        self.Type = "Phone"
        self.Confidence = 25
            

    def parse(self, dataString, **kwargs):
        dataString = dataString.strip()
        
        if len(dataString) > 30:
            return self.result(False)
            
        digits = [c for c in dataString if c in string.digits]
        letter_set = set()
        letters = [c for c in dataString if c in string.letters and c not in letter_set and not letter_set.add(c)]
        punctuation = [c for c in dataString if c in string.punctuation or c in string.whitespace]
        
        if '+' in punctuation or '*' in punctuation:
            if dataString[0] not in ['+','*']:
                return self.result(False)
        
        if len(letters) > 3:
            return self.result(False)
            
        if len(digits) < 7:
            return self.result(False)
            
        if len(digits) < (len(punctuation)  + len(letters)):
            return self.result(False)
            
        if len(punctuation) >= 1 and (punctuation[0] == ":" or punctuation[0] == "."):
            return self.result(False) # more likely it's an IP address
            
        if len(punctuation) == 0:
            if len(digits) != 7 and len(digits) != 10 and len(digits) != 11:
                self.Confidence = 5 #probably just a regular number
        else:
            if ',' in punctuation:
                self.Confidence = 5
        
        #checking for existence of only known phone number related characters
        phoneChars = re.compile("""^
           ([\(\)\+\*\-0-9/ ])*
           $""", re.VERBOSE)
        
        if phoneChars.match(dataString):
            
            # if we have these special chars, we know they only behave certain ways
            if '(' in punctuation or ')' in punctuation or '+' in punctuation or '*' in punctuation:
                
                # these chars would be the ones starting a phone number if we found special chars
                if dataString[0] not in ['+','*','1','(']:
                    return self.result(False)
                    
                # Starts with 1, but still contains +/* = fail
                if dataString[0] == '1':
                    if '+' in punctuation or '*' in punctuation:
                        return self.result(False)
                
            # These are the valid lengths for phone number digits
            # some intl phone numbers have 12/13 digits
            if len(digits) in [7,10,11,12,13]:
                
                slashPhone = re.compile('[0-9]{3}/[0-9]{7}|\([0-9]{3,4}\)[0-9]{7}');
                
                #if our digits are of a possible right length, and we contain dashes or whitespace, probably a phone number
                if '-' in punctuation or ' ' in punctuation:
                    self.Confidence = 90
                    
                elif slashPhone.match(dataString):
                    self.Confidence = 80
                
                # could be a phone number, probably an integer or something along those lines
                else:
                    self.Confidence = 15
                                
        return self.result(True, "Phone Number")

    def format(self, number):
        chunks = re.split('[\.,!\?;\- ]', number)
        format = self.determine_phone_format(chunks)
        
        if not format:
            return '-'.join(chunks)
            
        rendered_phone = ''
        render_format = format[3]
        render_index = 0
        phone_digits = list(''.join(chunks))
        
        for c in list(render_format):
            if c == '#':
                rendered_phone += phone_digits[render_index]
                render_index += 1
            else:
                if c == phone_digits[render_index]:
                    render_index += 1
                rendered_phone += c
                
        return {
            'format': render_format,
            'country': format[0],
            'clean': rendered_phone
        }
        
    def determine_phone_format(self, chunks):
        formats = (
            ('USA', 1, (
                '###-###-####',
                '1-###-###-####'
            ), '+1 (###) ###-####'),
            ('Denmark', 45, (
                '##-##-##-##',
                '####-####'
            )),
            ('France', 33, (
                '0#-##-##-##-##',
            )),
        )
        
        for country in formats:
            for format in country[2]:
                if self.does_phone_match_format(chunks, format, country[1]):
                    return country
        
        return None
        
    def does_phone_match_format(self, phone, format, calling_code):
        format_chunks = format.split("-")
        if len(phone) != len(format_chunks):
            return False
        
        zipped_chunks = zip(phone, format_chunks)
        
        for chunk in zipped_chunks:
            if len(chunk[0]) != len(chunk[1]):
                return False
                
            zipped_numbers = zip(list(chunk[0]), list(chunk[1]))
            
            for num_format in zipped_numbers:
                phone_character = num_format[0]
                format_character = num_format[1]
                
                if not phone_character in string.digits:
                    return False
                    
                if format_character != '#' and format_character != phone_character:
                    return False
        
        return True

from pygments.lexers.agile import PerlLexer, PythonLexer, RubyLexer
from pygments.lexers.compiled import CLexer, CppLexer
from pygments.lexers.dotnet import CSharpLexer, VbNetLexer
from pygments.lexers.jvm import JavaLexer
from pygments.lexers.web import ActionScript3Lexer, PhpLexer, JavascriptLexer
from pygments import lex
from pygments.token import Token
import threading


class ProgrammingLexerThread (threading.Thread):
    """
    Represents a thread that will handle one parser parsing request
    """

    lexer = None
    dataString = None
    result = None

    def __init__(self, lexerId, lexer, dataString):
        self.threadId = lexerId
        self.lexer = lexer
        self.dataString = dataString
        threading.Thread.__init__(self)

    def run(self):
        # lexing the data to see what lexers can tokenize it
        tokens = [tok for tok, text in lex(self.dataString, self.lexer) if (tok != Token.Text and text != '')]
        tokenCount = len(tokens)

        # Errors mean we definitely didn't find the right language
        if Token.Error in tokens or tokenCount == 0:
            self.result = False
        else:
            self.result = tokenCount


class ProgrammingLexer:

    lexers = {
        'actionscript': ActionScript3Lexer(),
        'c': CLexer(),
        'cpp': CppLexer(),
        'cs': CSharpLexer(),
        'java': JavaLexer(),
        'javascript': JavascriptLexer(),
        'perl': PerlLexer(),
        'php': PhpLexer(startinline=True),
        'python': PythonLexer(),
        'ruby': RubyLexer(),
        'vb': VbNetLexer(),
    }

    matchedLanguages = []
    data = None


    def __init__(self, matchedLangs, dataString):
        self.matchedLanguages = matchedLangs
        self.data = dataString


    def lex(self):
        '''
        For every possible matched language, we run a lexer to see if we can eliminate
        it as a possible match. If we detect errors, or have no lexer matches, we remove it from the list.
        '''

        results = {}
        threads = []
        
        # Looping through each matched language that has a lexer
        for lexerId, lexer in [[lexid, lxr] for lexid, lxr in self.lexers.items() if lexid in self.matchedLanguages]:
            # Creating a thread for each lexer
            thread = ProgrammingLexerThread(lexerId, lexer, self.data)
            thread.start()
            threads.append(thread)

        for t in threads:
            t.join()

        for t in [th for th in threads if th.result]:
            results[t.threadId] = t.result

        return results

"""Pexpect is a Python module for spawning child applications and controlling
them automatically. Pexpect can be used for automating interactive applications
such as ssh, ftp, passwd, telnet, etc. It can be used to a automate setup
scripts for duplicating software package installations on different servers. It
can be used for automated software testing. Pexpect is in the spirit of Don
Libes' Expect, but Pexpect is pure Python. Other Expect-like modules for Python
require TCL and Expect or require C extensions to be compiled. Pexpect does not
use C, Expect, or TCL extensions. It should work on any platform that supports
the standard Python pty module. The Pexpect interface focuses on ease of use so
that simple tasks are easy.

There are two main interfaces to the Pexpect system; these are the function,
run() and the class, spawn. The spawn class is more powerful. The run()
function is simpler than spawn, and is good for quickly calling program. When
you call the run() function it executes a given program and then returns the
output. This is a handy replacement for os.system().

For example::

    pexpect.run('ls -la')

The spawn class is the more powerful interface to the Pexpect system. You can
use this to spawn a child program then interact with it by sending input and
expecting responses (waiting for patterns in the child's output).

For example::

    child = pexpect.spawn('scp foo myname@host.example.com:.')
    child.expect ('Password:')
    child.sendline (mypassword)

This works even for commands that ask for passwords or other input outside of
the normal stdio streams. For example, ssh reads input directly from the TTY
device which bypasses stdin.

Credits: Noah Spurrier, Richard Holden, Marco Molteni, Kimberley Burchett,
Robert Stone, Hartmut Goebel, Chad Schroeder, Erick Tryzelaar, Dave Kirby, Ids
vander Molen, George Todd, Noel Taylor, Nicolas D. Cesar, Alexander Gattin,
Jacques-Etienne Baudoux, Geoffrey Marshall, Francisco Lourenco, Glen Mabey,
Karthik Gurusamy, Fernando Perez, Corey Minyard, Jon Cohen, Guillaume
Chazarain, Andrew Ryan, Nick Craig-Wood, Andrew Stone, Jorgen Grahn, John
Spiegel, Jan Grant, Shane Kerr and Thomas Kluyver. Let me know if I forgot anyone.

Pexpect is free, open source, and all that good stuff.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Pexpect Copyright (c) 2008-2011 Noah Spurrier
http://pexpect.sourceforge.net/
"""

try:
    import os, sys, time
    import select
    import re
    import struct
    import resource
    import types
    import pty
    import tty
    import termios
    import fcntl
    import errno
    import traceback
    import signal
except ImportError, e:
    raise ImportError (str(e) + """

A critical module was not found. Probably this operating system does not
support it. Pexpect is intended for UNIX-like operating systems.""")

__version__ = '2.6.dev'
version = __version__
version_info = (2,6,'dev')
__all__ = ['ExceptionPexpect', 'EOF', 'TIMEOUT', 'spawn', 'spawnb', 'run', 'which',
    'split_command_line', '__version__']

# Exception classes used by this module.
class ExceptionPexpect(Exception):

    """Base class for all exceptions raised by this module.
    """

    def __init__(self, value):

        self.value = value

    def __str__(self):

        return str(self.value)

    def get_trace(self):

        """This returns an abbreviated stack trace with lines that only concern
        the caller. In other words, the stack trace inside the Pexpect module
        is not included. """

        tblist = traceback.extract_tb(sys.exc_info()[2])
        #tblist = filter(self.__filter_not_pexpect, tblist)
        tblist = [item for item in tblist if self.__filter_not_pexpect(item)]
        tblist = traceback.format_list(tblist)
        return ''.join(tblist)

    def __filter_not_pexpect(self, trace_list_item):

        """This returns True if list item 0 the string 'pexpect.py' in it. """

        if trace_list_item[0].find('pexpect.py') == -1:
            return True
        else:
            return False

class EOF(ExceptionPexpect):

    """Raised when EOF is read from a child. This usually means the child has exited."""

class TIMEOUT(ExceptionPexpect):

    """Raised when a read time exceeds the timeout. """

##class TIMEOUT_PATTERN(TIMEOUT):
##    """Raised when the pattern match time exceeds the timeout.
##    This is different than a read TIMEOUT because the child process may
##    give output, thus never give a TIMEOUT, but the output
##    may never match a pattern.
##    """
##class MAXBUFFER(ExceptionPexpect):
##    """Raised when a scan buffer fills before matching an expected pattern."""

PY3 = (sys.version_info[0] >= 3)

def _cast_bytes(s, enc):
    if isinstance(s, unicode):
        return s.encode(enc)
    return s

def _cast_unicode(s, enc):
    if isinstance(s, bytes):
        return s.decode(enc)
    return s

re_type = type(re.compile(''))

def run (command, timeout=-1, withexitstatus=False, events=None, extra_args=None,
         logfile=None, cwd=None, env=None, encoding='utf-8'):

    """
    This function runs the given command; waits for it to finish; then
    returns all output as a string. STDERR is included in output. If the full
    path to the command is not given then the path is searched.

    Note that lines are terminated by CR/LF (\\r\\n) combination even on
    UNIX-like systems because this is the standard for pseudo ttys. If you set
    'withexitstatus' to true, then run will return a tuple of (command_output,
    exitstatus). If 'withexitstatus' is false then this returns just
    command_output.

    The run() function can often be used instead of creating a spawn instance.
    For example, the following code uses spawn::

        from pexpect import *
        child = spawn('scp foo myname@host.example.com:.')
        child.expect ('(?i)password')
        child.sendline (mypassword)

    The previous code can be replace with the following::

        from pexpect import *
        run ('scp foo myname@host.example.com:.', events={'(?i)password': mypassword})

    Examples
    ========

    Start the apache daemon on the local machine::

        from pexpect import *
        run ("/usr/local/apache/bin/apachectl start")

    Check in a file using SVN::

        from pexpect import *
        run ("svn ci -m 'automatic commit' my_file.py")

    Run a command and capture exit status::

        from pexpect import *
        (command_output, exitstatus) = run ('ls -l /bin', withexitstatus=1)

    Tricky Examples
    ===============

    The following will run SSH and execute 'ls -l' on the remote machine. The
    password 'secret' will be sent if the '(?i)password' pattern is ever seen::

        run ("ssh username@machine.example.com 'ls -l'", events={'(?i)password':'secret\\n'})

    This will start mencoder to rip a video from DVD. This will also display
    progress ticks every 5 seconds as it runs. For example::

        from pexpect import *
        def print_ticks(d):
            print d['event_count'],
        run ("mencoder dvd://1 -o video.avi -oac copy -ovc copy", events={TIMEOUT:print_ticks}, timeout=5)

    The 'events' argument should be a dictionary of patterns and responses.
    Whenever one of the patterns is seen in the command out run() will send the
    associated response string. Note that you should put newlines in your
    string if Enter is necessary. The responses may also contain callback
    functions. Any callback is function that takes a dictionary as an argument.
    The dictionary contains all the locals from the run() function, so you can
    access the child spawn object or any other variable defined in run()
    (event_count, child, and extra_args are the most useful). A callback may
    return True to stop the current run process otherwise run() continues until
    the next event. A callback may also return a string which will be sent to
    the child. 'extra_args' is not used by directly run(). It provides a way to
    pass data to a callback function through run() through the locals
    dictionary passed to a callback."""

    if timeout == -1:
        child = spawn(command, maxread=2000, logfile=logfile, cwd=cwd, env=env,
                      encoding=encoding)
    else:
        child = spawn(command, timeout=timeout, maxread=2000, logfile=logfile,
                      cwd=cwd, env=env, encoding=encoding)
    if events is not None:
        patterns = events.keys()
        responses = events.values()
    else:
        patterns=None # We assume that EOF or TIMEOUT will save us.
        responses=None
    child_result_list = []
    event_count = 0
    while 1:
        try:
            index = child.expect (patterns)
            if isinstance(child.after, basestring):
                child_result_list.append(child.before + child.after)
            else: # child.after may have been a TIMEOUT or EOF, so don't cat those.
                child_result_list.append(child.before)
            if isinstance(responses[index], basestring):
                child.send(responses[index])
            elif type(responses[index]) is types.FunctionType:
                callback_result = responses[index](locals())
                sys.stdout.flush()
                if isinstance(callback_result, basestring):
                    child.send(callback_result)
                elif callback_result:
                    break
            else:
                raise TypeError ('The callback must be a string or function type.')
            event_count = event_count + 1
        except TIMEOUT, e:
            child_result_list.append(child.before)
            break
        except EOF, e:
            child_result_list.append(child.before)
            break
    child_result = child._empty_buffer.join(child_result_list)
    if withexitstatus:
        child.close()
        return (child_result, child.exitstatus)
    else:
        return child_result

class spawnb(object):
    """Use this class to start and control child applications with a pure-bytes
    interface."""
    
    _buffer_type = bytes
    def _cast_buffer_type(self, s):
        return _cast_bytes(s, self.encoding)
    _empty_buffer = b''
    _pty_newline = b'\r\n'
    
    # Some code needs this to exist, but it's mainly for the spawn subclass.
    encoding = 'utf-8'

    def __init__(self, command, args=[], timeout=30, maxread=2000, searchwindowsize=None,
                 logfile=None, cwd=None, env=None):

        """This is the constructor. The command parameter may be a string that
        includes a command and any arguments to the command. For example::

            child = pexpect.spawn ('/usr/bin/ftp')
            child = pexpect.spawn ('/usr/bin/ssh user@example.com')
            child = pexpect.spawn ('ls -latr /tmp')

        You may also construct it with a list of arguments like so::

            child = pexpect.spawn ('/usr/bin/ftp', [])
            child = pexpect.spawn ('/usr/bin/ssh', ['user@example.com'])
            child = pexpect.spawn ('ls', ['-latr', '/tmp'])

        After this the child application will be created and will be ready to
        talk to. For normal use, see expect() and send() and sendline().

        Remember that Pexpect does NOT interpret shell meta characters such as
        redirect, pipe, or wild cards (>, |, or *). This is a common mistake.
        If you want to run a command and pipe it through another command then
        you must also start a shell. For example::

            child = pexpect.spawn('/bin/bash -c "ls -l | grep LOG > log_list.txt"')
            child.expect(pexpect.EOF)

        The second form of spawn (where you pass a list of arguments) is useful
        in situations where you wish to spawn a command and pass it its own
        argument list. This can make syntax more clear. For example, the
        following is equivalent to the previous example::

            shell_cmd = 'ls -l | grep LOG > log_list.txt'
            child = pexpect.spawn('/bin/bash', ['-c', shell_cmd])
            child.expect(pexpect.EOF)

        The maxread attribute sets the read buffer size. This is maximum number
        of bytes that Pexpect will try to read from a TTY at one time. Setting
        the maxread size to 1 will turn off buffering. Setting the maxread
        value higher may help performance in cases where large amounts of
        output are read back from the child. This feature is useful in
        conjunction with searchwindowsize.

        The searchwindowsize attribute sets the how far back in the incomming
        seach buffer Pexpect will search for pattern matches. Every time
        Pexpect reads some data from the child it will append the data to the
        incomming buffer. The default is to search from the beginning of the
        imcomming buffer each time new data is read from the child. But this is
        very inefficient if you are running a command that generates a large
        amount of data where you want to match The searchwindowsize does not
        effect the size of the incomming data buffer. You will still have
        access to the full buffer after expect() returns.

        The logfile member turns on or off logging. All input and output will
        be copied to the given file object. Set logfile to None to stop
        logging. This is the default. Set logfile to sys.stdout to echo
        everything to standard output. The logfile is flushed after each write.

        Example log input and output to a file::

            child = pexpect.spawn('some_command')
            fout = open('mylog.txt','w')
            child.logfile = fout

        Example log to stdout::

            child = pexpect.spawn('some_command')
            child.logfile = sys.stdout

        The logfile_read and logfile_send members can be used to separately log
        the input from the child and output sent to the child. Sometimes you
        don't want to see everything you write to the child. You only want to
        log what the child sends back. For example::

            child = pexpect.spawn('some_command')
            child.logfile_read = sys.stdout

        To separately log output sent to the child use logfile_send::

            self.logfile_send = fout

        The delaybeforesend helps overcome a weird behavior that many users
        were experiencing. The typical problem was that a user would expect() a
        "Password:" prompt and then immediately call sendline() to send the
        password. The user would then see that their password was echoed back
        to them. Passwords don't normally echo. The problem is caused by the
        fact that most applications print out the "Password" prompt and then
        turn off stdin echo, but if you send your password before the
        application turned off echo, then you get your password echoed.
        Normally this wouldn't be a problem when interacting with a human at a
        real keyboard. If you introduce a slight delay just before writing then
        this seems to clear up the problem. This was such a common problem for
        many users that I decided that the default pexpect behavior should be
        to sleep just before writing to the child application. 1/20th of a
        second (50 ms) seems to be enough to clear up the problem. You can set
        delaybeforesend to 0 to return to the old behavior. Most Linux machines
        don't like this to be below 0.03. I don't know why.

        Note that spawn is clever about finding commands on your path.
        It uses the same logic that "which" uses to find executables.

        If you wish to get the exit status of the child you must call the
        close() method. The exit or signal status of the child will be stored
        in self.exitstatus or self.signalstatus. If the child exited normally
        then exitstatus will store the exit return code and signalstatus will
        be None. If the child was terminated abnormally with a signal then
        signalstatus will store the signal value and exitstatus will be None.
        If you need more detail you can also read the self.status member which
        stores the status returned by os.waitpid. You can interpret this using
        os.WIFEXITED/os.WEXITSTATUS or os.WIFSIGNALED/os.TERMSIG. """

        self.STDIN_FILENO = pty.STDIN_FILENO
        self.STDOUT_FILENO = pty.STDOUT_FILENO
        self.STDERR_FILENO = pty.STDERR_FILENO
        self.stdin = sys.stdin
        self.stdout = sys.stdout
        self.stderr = sys.stderr

        self.searcher = None
        self.ignorecase = False
        self.before = None
        self.after = None
        self.match = None
        self.match_index = None
        self.terminated = True
        self.exitstatus = None
        self.signalstatus = None
        self.status = None # status returned by os.waitpid
        self.flag_eof = False
        self.pid = None
        self.child_fd = -1 # initially closed
        self.timeout = timeout
        self.delimiter = EOF
        self.logfile = logfile
        self.logfile_read = None # input from child (read_nonblocking)
        self.logfile_send = None # output to send (send, sendline)
        self.maxread = maxread # max bytes to read at one time into buffer
        self.buffer = self._empty_buffer # This is the read buffer. See maxread.
        self.searchwindowsize = searchwindowsize # Anything before searchwindowsize point is preserved, but not searched.
        # Most Linux machines don't like delaybeforesend to be below 0.03 (30 ms).
        self.delaybeforesend = 0.05 # Sets sleep time used just before sending data to child. Time in seconds.
        self.delayafterclose = 0.1 # Sets delay in close() method to allow kernel time to update process status. Time in seconds.
        self.delayafterterminate = 0.1 # Sets delay in terminate() method to allow kernel time to update process status. Time in seconds.
        self.softspace = False # File-like object.
        self.name = '<' + repr(self) + '>' # File-like object.
        self.closed = True # File-like object.
        self.cwd = cwd
        self.env = env
        self.__irix_hack = (sys.platform.lower().find('irix')>=0) # This flags if we are running on irix
        # Solaris uses internal __fork_pty(). All others use pty.fork().
        if 'solaris' in sys.platform.lower() or 'sunos5' in sys.platform.lower():
            self.use_native_pty_fork = False
        else:
            self.use_native_pty_fork = True


        # allow dummy instances for subclasses that may not use command or args.
        if command is None:
            self.command = None
            self.args = None
            self.name = '<pexpect factory incomplete>'
        else:
            self._spawn (command, args)

    def __del__(self):

        """This makes sure that no system resources are left open. Python only
        garbage collects Python objects. OS file descriptors are not Python
        objects, so they must be handled explicitly. If the child file
        descriptor was opened outside of this class (passed to the constructor)
        then this does not close it. """

        if not self.closed:
            # It is possible for __del__ methods to execute during the
            # teardown of the Python VM itself. Thus self.close() may
            # trigger an exception because os.close may be None.
            # -- Fernando Perez
            try:
                self.close()
            except:
                pass

    def __str__(self):

        """This returns a human-readable string that represents the state of
        the object. """

        s = []
        s.append(repr(self))
        s.append('version: ' + __version__)
        s.append('command: ' + str(self.command))
        s.append('args: ' + str(self.args))
        s.append('searcher: ' + str(self.searcher))
        s.append('buffer (last 100 chars): ' + str(self.buffer)[-100:])
        s.append('before (last 100 chars): ' + str(self.before)[-100:])
        s.append('after: ' + str(self.after))
        s.append('match: ' + str(self.match))
        s.append('match_index: ' + str(self.match_index))
        s.append('exitstatus: ' + str(self.exitstatus))
        s.append('flag_eof: ' + str(self.flag_eof))
        s.append('pid: ' + str(self.pid))
        s.append('child_fd: ' + str(self.child_fd))
        s.append('closed: ' + str(self.closed))
        s.append('timeout: ' + str(self.timeout))
        s.append('delimiter: ' + str(self.delimiter))
        s.append('logfile: ' + str(self.logfile))
        s.append('logfile_read: ' + str(self.logfile_read))
        s.append('logfile_send: ' + str(self.logfile_send))
        s.append('maxread: ' + str(self.maxread))
        s.append('ignorecase: ' + str(self.ignorecase))
        s.append('searchwindowsize: ' + str(self.searchwindowsize))
        s.append('delaybeforesend: ' + str(self.delaybeforesend))
        s.append('delayafterclose: ' + str(self.delayafterclose))
        s.append('delayafterterminate: ' + str(self.delayafterterminate))
        return '\n'.join(s)

    def _spawn(self,command,args=[]):

        """This starts the given command in a child process. This does all the
        fork/exec type of stuff for a pty. This is called by __init__. If args
        is empty then command will be parsed (split on spaces) and args will be
        set to parsed arguments. """

        # The pid and child_fd of this object get set by this method.
        # Note that it is difficult for this method to fail.
        # You cannot detect if the child process cannot start.
        # So the only way you can tell if the child process started
        # or not is to try to read from the file descriptor. If you get
        # EOF immediately then it means that the child is already dead.
        # That may not necessarily be bad because you may haved spawned a child
        # that performs some task; creates no stdout output; and then dies.

        # If command is an int type then it may represent a file descriptor.
        if type(command) == type(0):
            raise ExceptionPexpect ('Command is an int type. If this is a file descriptor then maybe you want to use fdpexpect.fdspawn which takes an existing file descriptor instead of a command string.')

        if type (args) != type([]):
            raise TypeError ('The argument, args, must be a list.')

        if args == []:
            self.args = split_command_line(command)
            self.command = self.args[0]
        else:
            self.args = args[:] # work with a copy
            self.args.insert (0, command)
            self.command = command

        command_with_path = which(self.command)
        if command_with_path is None:
            raise ExceptionPexpect ('The command was not found or was not executable: %s.' % self.command)
        self.command = command_with_path
        self.args[0] = self.command

        self.name = '<' + ' '.join (self.args) + '>'

        assert self.pid is None, 'The pid member should be None.'
        assert self.command is not None, 'The command member should not be None.'

        if self.use_native_pty_fork:
            try:
                self.pid, self.child_fd = pty.fork()
            except OSError, e:
                raise ExceptionPexpect('Error! pty.fork() failed: ' + str(e))
        else: # Use internal __fork_pty
            self.pid, self.child_fd = self.__fork_pty()

        if self.pid == 0: # Child
            try:
                self.child_fd = sys.stdout.fileno() # used by setwinsize()
                self.setwinsize(24, 80)
            except:
                # Some platforms do not like setwinsize (Cygwin).
                # This will cause problem when running applications that
                # are very picky about window size.
                # This is a serious limitation, but not a show stopper.
                pass
            # Do not allow child to inherit open file descriptors from parent.
            max_fd = resource.getrlimit(resource.RLIMIT_NOFILE)[0]
            for i in range (3, max_fd):
                try:
                    os.close (i)
                except OSError:
                    pass

            # I don't know why this works, but ignoring SIGHUP fixes a
            # problem when trying to start a Java daemon with sudo
            # (specifically, Tomcat).
            signal.signal(signal.SIGHUP, signal.SIG_IGN)

            if self.cwd is not None:
                os.chdir(self.cwd)
            if self.env is None:
                os.execv(self.command, self.args)
            else:
                os.execvpe(self.command, self.args, self.env)

        # Parent
        self.terminated = False
        self.closed = False

    def __fork_pty(self):

        """This implements a substitute for the forkpty system call. This
        should be more portable than the pty.fork() function. Specifically,
        this should work on Solaris.

        Modified 10.06.05 by Geoff Marshall: Implemented __fork_pty() method to
        resolve the issue with Python's pty.fork() not supporting Solaris,
        particularly ssh. Based on patch to posixmodule.c authored by Noah
        Spurrier::

            http://mail.python.org/pipermail/python-dev/2003-May/035281.html

        """

        parent_fd, child_fd = os.openpty()
        if parent_fd < 0 or child_fd < 0:
            raise ExceptionPexpect, "Error! Could not open pty with os.openpty()."

        pid = os.fork()
        if pid < 0:
            raise ExceptionPexpect, "Error! Failed os.fork()."
        elif pid == 0:
            # Child.
            os.close(parent_fd)
            self.__pty_make_controlling_tty(child_fd)

            os.dup2(child_fd, 0)
            os.dup2(child_fd, 1)
            os.dup2(child_fd, 2)

            if child_fd > 2:
                os.close(child_fd)
        else:
            # Parent.
            os.close(child_fd)

        return pid, parent_fd

    def __pty_make_controlling_tty(self, tty_fd):

        """This makes the pseudo-terminal the controlling tty. This should be
        more portable than the pty.fork() function. Specifically, this should
        work on Solaris. """

        child_name = os.ttyname(tty_fd)

        # Disconnect from controlling tty. Harmless if not already connected.
        try:
            fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY);
            if fd >= 0:
                os.close(fd)
        except:
            # Already disconnected. This happens if running inside cron.
            pass

        os.setsid()

        # Verify we are disconnected from controlling tty
        # by attempting to open it again.
        try:
            fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY);
            if fd >= 0:
                os.close(fd)
                raise ExceptionPexpect, "Error! Failed to disconnect from controlling tty. It is still possible to open /dev/tty."
        except:
            # Good! We are disconnected from a controlling tty.
            pass

        # Verify we can open child pty.
        fd = os.open(child_name, os.O_RDWR);
        if fd < 0:
            raise ExceptionPexpect, "Error! Could not open child pty, " + child_name
        else:
            os.close(fd)

        # Verify we now have a controlling tty.
        fd = os.open("/dev/tty", os.O_WRONLY)
        if fd < 0:
            raise ExceptionPexpect, "Error! Could not open controlling tty, /dev/tty"
        else:
            os.close(fd)

    def fileno (self):   # File-like object.

        """This returns the file descriptor of the pty for the child.
        """

        return self.child_fd

    def close (self, force=True):   # File-like object.

        """This closes the connection with the child application. Note that
        calling close() more than once is valid. This emulates standard Python
        behavior with files. Set force to True if you want to make sure that
        the child is terminated (SIGKILL is sent if the child ignores SIGHUP
        and SIGINT). """

        if not self.closed:
            self.flush()
            os.close (self.child_fd)
            time.sleep(self.delayafterclose) # Give kernel time to update process status.
            if self.isalive():
                if not self.terminate(force):
                    raise ExceptionPexpect ('close() could not terminate the child using terminate()')
            self.child_fd = -1
            self.closed = True
            #self.pid = None

    def flush (self):   # File-like object.

        """This does nothing. It is here to support the interface for a
        File-like object. """

        pass

    def isatty (self):   # File-like object.

        """This returns True if the file descriptor is open and connected to a
        tty(-like) device, else False. """

        return os.isatty(self.child_fd)

    def waitnoecho (self, timeout=-1):

        """This waits until the terminal ECHO flag is set False. This returns
        True if the echo mode is off. This returns False if the ECHO flag was
        not set False before the timeout. This can be used to detect when the
        child is waiting for a password. Usually a child application will turn
        off echo mode when it is waiting for the user to enter a password. For
        example, instead of expecting the "password:" prompt you can wait for
        the child to set ECHO off::

            p = pexpect.spawn ('ssh user@example.com')
            p.waitnoecho()
            p.sendline(mypassword)

        If timeout==-1 then this method will use the value in self.timeout.
        If timeout==None then this method to block until ECHO flag is False.
        """

        if timeout == -1:
            timeout = self.timeout
        if timeout is not None:
            end_time = time.time() + timeout
        while True:
            if not self.getecho():
                return True
            if timeout < 0 and timeout is not None:
                return False
            if timeout is not None:
                timeout = end_time - time.time()
            time.sleep(0.1)

    def getecho (self):

        """This returns the terminal echo mode. This returns True if echo is
        on or False if echo is off. Child applications that are expecting you
        to enter a password often set ECHO False. See waitnoecho(). """

        attr = termios.tcgetattr(self.child_fd)
        if attr[3] & termios.ECHO:
            return True
        return False

    def setecho (self, state):

        """This sets the terminal echo mode on or off. Note that anything the
        child sent before the echo will be lost, so you should be sure that
        your input buffer is empty before you call setecho(). For example, the
        following will work as expected::

            p = pexpect.spawn('cat')
            p.sendline ('1234') # We will see this twice (once from tty echo and again from cat).
            p.expect (['1234'])
            p.expect (['1234'])
            p.setecho(False) # Turn off tty echo
            p.sendline ('abcd') # We will set this only once (echoed by cat).
            p.sendline ('wxyz') # We will set this only once (echoed by cat)
            p.expect (['abcd'])
            p.expect (['wxyz'])

        The following WILL NOT WORK because the lines sent before the setecho
        will be lost::

            p = pexpect.spawn('cat')
            p.sendline ('1234') # We will see this twice (once from tty echo and again from cat).
            p.setecho(False) # Turn off tty echo
            p.sendline ('abcd') # We will set this only once (echoed by cat).
            p.sendline ('wxyz') # We will set this only once (echoed by cat)
            p.expect (['1234'])
            p.expect (['1234'])
            p.expect (['abcd'])
            p.expect (['wxyz'])
        """

        self.child_fd
        attr = termios.tcgetattr(self.child_fd)
        if state:
            attr[3] = attr[3] | termios.ECHO
        else:
            attr[3] = attr[3] & ~termios.ECHO
        # I tried TCSADRAIN and TCSAFLUSH, but these were inconsistent
        # and blocked on some platforms. TCSADRAIN is probably ideal if it worked.
        termios.tcsetattr(self.child_fd, termios.TCSANOW, attr)

    def read_nonblocking (self, size = 1, timeout = -1):

        """This reads at most size bytes from the child application. It
        includes a timeout. If the read does not complete within the timeout
        period then a TIMEOUT exception is raised. If the end of file is read
        then an EOF exception will be raised. If a log file was set using
        setlog() then all data will also be written to the log file.

        If timeout is None then the read may block indefinitely. If timeout is -1
        then the self.timeout value is used. If timeout is 0 then the child is
        polled and if there was no data immediately ready then this will raise
        a TIMEOUT exception.

        The timeout refers only to the amount of time to read at least one
        character. This is not effected by the 'size' parameter, so if you call
        read_nonblocking(size=100, timeout=30) and only one character is
        available right away then one character will be returned immediately.
        It will not wait for 30 seconds for another 99 characters to come in.

        This is a wrapper around os.read(). It uses select.select() to
        implement the timeout. """

        if self.closed:
            raise ValueError ('I/O operation on closed file in read_nonblocking().')

        if timeout == -1:
            timeout = self.timeout

        # Note that some systems such as Solaris do not give an EOF when
        # the child dies. In fact, you can still try to read
        # from the child_fd -- it will block forever or until TIMEOUT.
        # For this case, I test isalive() before doing any reading.
        # If isalive() is false, then I pretend that this is the same as EOF.
        if not self.isalive():
            r,w,e = self.__select([self.child_fd], [], [], 0) # timeout of 0 means "poll"
            if not r:
                self.flag_eof = True
                raise EOF ('End Of File (EOF) in read_nonblocking(). Braindead platform.')
        elif self.__irix_hack:
            # This is a hack for Irix. It seems that Irix requires a long delay before checking isalive.
            # This adds a 2 second delay, but only when the child is terminated.
            r, w, e = self.__select([self.child_fd], [], [], 2)
            if not r and not self.isalive():
                self.flag_eof = True
                raise EOF ('End Of File (EOF) in read_nonblocking(). Pokey platform.')

        r,w,e = self.__select([self.child_fd], [], [], timeout)

        if not r:
            if not self.isalive():
                # Some platforms, such as Irix, will claim that their processes are alive;
                # then timeout on the select; and then finally admit that they are not alive.
                self.flag_eof = True
                raise EOF ('End of File (EOF) in read_nonblocking(). Very pokey platform.')
            else:
                raise TIMEOUT ('Timeout exceeded in read_nonblocking().')

        if self.child_fd in r:
            try:
                s = os.read(self.child_fd, size)
            except OSError, e: # Linux does this
                self.flag_eof = True
                raise EOF ('End Of File (EOF) in read_nonblocking(). Exception style platform.')
            if s == b'': # BSD style
                self.flag_eof = True
                raise EOF ('End Of File (EOF) in read_nonblocking(). Empty string style platform.')

            s2 = self._cast_buffer_type(s)
            if self.logfile is not None:
                self.logfile.write(s2)
                self.logfile.flush()
            if self.logfile_read is not None:
                self.logfile_read.write(s2)
                self.logfile_read.flush()

            return s

        raise ExceptionPexpect ('Reached an unexpected state in read_nonblocking().')

    def read (self, size = -1):         # File-like object.
        """This reads at most "size" bytes from the file (less if the read hits
        EOF before obtaining size bytes). If the size argument is negative or
        omitted, read all data until EOF is reached. The bytes are returned as
        a string object. An empty string is returned when EOF is encountered
        immediately. """

        if size == 0:
            return self._empty_buffer
        if size < 0:
            self.expect (self.delimiter) # delimiter default is EOF
            return self.before

        # I could have done this more directly by not using expect(), but
        # I deliberately decided to couple read() to expect() so that
        # I would catch any bugs early and ensure consistant behavior.
        # It's a little less efficient, but there is less for me to
        # worry about if I have to later modify read() or expect().
        # Note, it's OK if size==-1 in the regex. That just means it
        # will never match anything in which case we stop only on EOF.
        if self._buffer_type is bytes:
            pat = (u'.{%d}' % size).encode('ascii')
        else:
            pat = u'.{%d}' % size
        cre = re.compile(pat, re.DOTALL)
        index = self.expect ([cre, self.delimiter]) # delimiter default is EOF
        if index == 0:
            return self.after ### self.before should be ''. Should I assert this?
        return self.before

    def readline(self, size = -1):
        """This reads and returns one entire line. A trailing newline is kept
        in the string, but may be absent when a file ends with an incomplete
        line. Note: This readline() looks for a \\r\\n pair even on UNIX
        because this is what the pseudo tty device returns. So contrary to what
        you may expect you will receive the newline as \\r\\n. An empty string
        is returned when EOF is hit immediately. Currently, the size argument is
        mostly ignored, so this behavior is not standard for a file-like
        object. If size is 0 then an empty string is returned. """

        if size == 0:
            return self._empty_buffer
        index = self.expect ([self._pty_newline, self.delimiter]) # delimiter default is EOF
        if index == 0:
            return self.before + self._pty_newline
        return self.before

    def __iter__ (self):    # File-like object.

        """This is to support iterators over a file-like object.
        """

        return self

    def next (self):    # File-like object.

        """This is to support iterators over a file-like object.
        """

        result = self.readline()
        if result == self._empty_buffer:
            raise StopIteration
        return result

    def readlines (self, sizehint = -1):    # File-like object.

        """This reads until EOF using readline() and returns a list containing
        the lines thus read. The optional "sizehint" argument is ignored. """

        lines = []
        while True:
            line = self.readline()
            if not line:
                break
            lines.append(line)
        return lines

    def write(self, s):   # File-like object.

        """This is similar to send() except that there is no return value.
        """

        self.send (s)

import logging
import os
import shutil
import sys

from pkg_resources import get_distribution
from pkg_resources import parse_version
import zc.buildout
import zc.recipe.egg

join = os.path.join

curdir = os.path.dirname(__file__)


class Recipe:

    def __init__(self, buildout, name, options):
        self.egg = zc.recipe.egg.Egg(buildout, options['recipe'], options)
        self.buildout, self.options, self.name = buildout, options, name

        options['location'] = os.path.join(
            buildout['buildout']['parts-directory'],
            self.name,
            )
        options['bin-directory'] = buildout['buildout']['bin-directory']
        options['scripts'] = '' # suppress script generation.

        _, self.zodb_ws = self.egg.working_set()

        # Relative path support for the generated scripts
        relative_paths = options.get(
            'relative-paths',
            buildout['buildout'].get('relative-paths', 'false'))
        if relative_paths == 'true':
            options['buildout-directory'] = buildout['buildout']['directory']
            self._relative_paths = options['buildout-directory']
        else:
            self._relative_paths = ''
            assert relative_paths == 'false'

    _ws_locations = None

    def ws_locations(self):
        if self._ws_locations is None:
            self._ws_locations = [d.location for d in self.zodb_ws]
        return self._ws_locations
    ws_locations = property(ws_locations)

    def install(self):
        options = self.options
        location = options['location']

        if os.path.exists(location):
            shutil.rmtree(location)

        self.module_paths = self.options.get('extra-paths', [])
        if self.module_paths:
            # Filter out empty directories
            self.module_paths = [p for p in self.module_paths.split('\n') if p]

        # this was taken from mkzeoinstance.py
        import zdaemon
        zdaemon_home = os.path.split(zdaemon.__path__[0])[0]

        import ZEO
        self.zodb3_home = os.path.dirname(os.path.dirname(ZEO.__file__))
        params = {
            "package": "zeo",
            "PACKAGE": "ZEO",
            "zodb3_home": self.zodb3_home,
            'zdaemon_home': zdaemon_home,
            "instance_home": location,
            "address": '8100', # will be overwritten later
            "python": options['executable'],
            }
        from zope.mkzeoinstance import ZEOInstanceBuilder
        ZEOInstanceBuilder().create(location, params)

        try:
            # Save the working set:
            open(os.path.join(location, 'etc', '.eggs'), 'w').write(
                '\n'.join(self.ws_locations))

            # Make a new zeo.conf based on options in buildout.cfg
            self.build_zeo_conf()

            # Patch extra paths into binaries
            self.patch_binaries()

            # Install extra scripts
            self.install_scripts()

        except:
            # clean up
            shutil.rmtree(location)
            raise

        return location

    def update(self):
        options = self.options
        location = options['location']

        if os.path.exists(location):
            # See if we can stop. We need to see if the working set path
            # has changed.
            saved_path = os.path.join(location, 'etc', '.eggs')
            if os.path.isfile(saved_path):
                if (open(saved_path).read() != '\n'.join(self.ws_locations)):
                    # Something has changed. Blow away the instance.
                    self.install()

            # Nothing has changed.
            return location

        else:
            self.install()

        return location

    def build_zeo_conf(self):
        """Create a zeo.conf file
        """
        options = self.options
        location = options['location']
        instance_home = location

        base_dir = self.buildout['buildout']['directory']
        var_dir = options.get('var', os.path.join(base_dir, 'var'))
        if not os.path.exists(var_dir):
            os.makedirs(var_dir)

        self.pid_file = options.get(
            'pid-file',
            os.path.join(var_dir, self.name + '.pid'))

        zeo_conf_path = options.get('zeo-conf', None)
        if zeo_conf_path is not None:
            zeo_conf = "%%include %s" % os.path.abspath(zeo_conf_path)
        else:
            zeo_address = options.get('zeo-address', '8100')
            zeo_conf_additional = options.get('zeo-conf-additional', '')
            storage_number = options.get('storage-number', '1')

            monitor_address = options.get('monitor-address', '')
            if monitor_address:
                monitor_address = 'monitor-address %s' % monitor_address

            effective_user = options.get('effective-user', '')
            if effective_user:
                effective_user = 'user %s' % effective_user

            invalidation_queue_size = options.get('invalidation-queue-size',
                                                  '100')

            socket_name = options.get('socket-name',
                                      '%s/zeo.zdsock' % var_dir)
            socket_dir = os.path.dirname(socket_name)
            if not os.path.exists(socket_dir):
                os.makedirs(socket_dir)

            z_log_name = os.path.sep.join(('log', self.name + '.log'))
            zeo_log_level = options.get('zeo-log-level', 'info')
            zeo_log_custom = options.get('zeo-log-custom', None)

            # if zeo-log is given, we use it to set the runner
            # logfile value in any case
            z_log_filename = options.get('zeo-log', z_log_name)
            z_log_filename = os.path.join(var_dir, z_log_filename)
            z_log_dir = os.path.dirname(z_log_filename)
            if not os.path.exists(z_log_dir):
                os.makedirs(z_log_dir)

            # zeo-log-custom superseeds zeo-log
            logformat=options.get('zeo-log-format', '%(asctime)s %(message)s')
            if zeo_log_custom is None:
                z_log = z_log_file % {
                    'filename': z_log_filename, 'logformat': logformat}
            else:
                z_log = zeo_log_custom

            file_storage = os.path.sep.join(('filestorage', 'Data.fs'))
            file_storage = options.get('file-storage', file_storage)
            file_storage = os.path.join(var_dir, file_storage)
            file_storage_dir = os.path.dirname(file_storage)
            if not os.path.exists(file_storage_dir):
                os.makedirs(file_storage_dir)

            if options.get('authentication-database', ''):
                authentication = authentication_template % \
                        dict(database=options.get('authentication-database'),
                             realm=options.get('authentication-realm', 'ZEO'))
            else:
                authentication = ''

            blob_storage = options.get('blob-storage', 'blobstorage')
            if blob_storage:
                blob_storage = os.path.join(var_dir, blob_storage)
                storage_template = blob_storage_template
            else:
                storage_template = file_storage_template

            effective_user = options.get('effective-user', '')
            if effective_user:
                effective_user = 'user %s' % effective_user

            pack_gc = options.get('pack-gc', '')
            if pack_gc.lower() == 'false':
                pack_gc = 'pack-gc false'

            pack_keep_old = options.get('pack-keep-old', '')
            if pack_keep_old.lower() == 'false':
                pack_keep_old = 'pack-keep-old false'

            storage = storage_template % dict(
                storage_number = storage_number,
                file_storage = file_storage,
                blob_storage = blob_storage,
                pack_gc = pack_gc,
                pack_keep_old = pack_keep_old,
                )

            zeo_conf = zeo_conf_template % dict(
                instance_home = instance_home,
                effective_user = effective_user,
                invalidation_queue_size = invalidation_queue_size,
                socket_name = socket_name,
                z_log = z_log,
                z_log_filename = z_log_filename,
                authentication = authentication,
                storage = storage,
                zeo_address = zeo_address,
                pid_file = self.pid_file,
                zeo_conf_additional = zeo_conf_additional,
                monitor_address = monitor_address,
                zeo_log_level = zeo_log_level,
                )

        zeo_conf_path = os.path.join(location, 'etc', 'zeo.conf')
        open(zeo_conf_path, 'w').write(zeo_conf)

    def patch_binaries(self):
        location = self.options['location']
        # XXX We need to patch the windows specific batch scripts
        # and they need a different path seperator
        path = (os.path.pathsep.join(self.ws_locations)
                + os.path.pathsep
                + os.path.pathsep.join(self.module_paths))

        for script_name in ('runzeo', 'zeoctl'):
            script_path = os.path.join(location, 'bin', script_name)
            script = open(script_path).read()
            script = script.replace('PYTHONPATH="$ZODB3_HOME"',
                                    'PYTHONPATH="%s"' % path)
            f = open(script_path, 'w')
            f.write(script)
            f.close()

    def install_scripts(self):
        options = self.options
        location = options['location']

        self.zeo_conf = options.get('zeo-conf', None)
        if self.zeo_conf is None:
            self.zeo_conf = os.path.join(location, 'etc', 'zeo.conf')

        _, ws = self.egg.working_set(['plone.recipe.zeoserver'])

        path = (os.path.pathsep.join(self.ws_locations)
                + os.path.pathsep
                + os.path.pathsep.join(self.module_paths))
        initialization = """
        import os; os.environ['PYTHONPATH'] = %r
        """.strip() % path
        zc.buildout.easy_install.scripts(
            [(self.name, 'plone.recipe.zeoserver.ctl', 'main')],
            ws, options['executable'], options['bin-directory'],
            initialization = initialization,
            arguments = ('\n        ["-C", %r]'
                         '\n        + sys.argv[1:]'
                         % self.zeo_conf),
            extra_paths=self.module_paths,
            relative_paths=self._relative_paths)

        # zeopack.py
        zeopack = options.get('zeopack', None)
        zeopack_script_name = options.get('zeopack-script-name', 'zeopack')
        zeopack_scripts = dict(zeopack=zeopack_script_name)
        if zeopack is not None:
            directory, filename = os.path.split(zeopack)
            if zeopack and os.path.exists(zeopack):
                zc.buildout.easy_install.scripts(
                    [('zeopack', os.path.splitext(filename)[0], 'main')],
                    ws, options['executable'], options['bin-directory'],
                    scripts=zeopack_scripts,
                    extra_paths = ws + [directory] + self.module_paths,
                    relative_paths=self._relative_paths,
                    )
        else:
            host = port = socket_path = ''
            zeo_address = options.get('zeo-address', '8100')
            parts = zeo_address.split(':')

            if len(parts) == 1:
                try:
                    # if the only argument is a port, which must be an int,
                    # we use 127.0.0.1 as the host by default
                    port = int(zeo_address)
                except ValueError:
                    # The address is a simple string, we now assume it is
                    # a path to a Unix socket file
                    socket_path = zeo_address
                else:
                    host = '127.0.0.1'
                    port = zeo_address
            else:
                host, port = parts

            username = options.get('pack-user', None)
            password = options.get('pack-password', None)
            if username is not None:
                realm = options.get('authentication-realm', 'ZEO')
            else:
                realm = None

            arg_list = [
                'host', 'port', 'unix', 'days',
                'username', 'password', 'realm', 'blob_dir', 'storage',
            ]
            arguments = dict(
                address=zeo_address,
                host=host,
                port=port,
                unix=socket_path,
                days=options.get('pack-days', 1),
                username=username,
                password=password,
                realm=realm,
                blob_dir=options.get('blob-storage', None),
            )
            arguments_info = ''
            for k, v in arguments.items():
                if not v:
                    arguments_info += '%s = None\n' % k
                else:
                    arguments_info += '%s = "%s"\n' % (k, v)

            arguments_info += ("import getopt; opts = "
                               "getopt.getopt(sys.argv[1:], 'S:B:W1')[0];\n"
                               "opts = dict(opts)\n"
                               "storage = opts.has_key('-S') and "
                               "opts['-S'] or '1'\n"
                               "blob_dir = opts.has_key('-B') and "
                               "opts['-B'] or blob_dir")

            # Make sure the recipe itself and its dependencies are on the path
            extra_paths = [ws.by_key[options['recipe']].location]
            extra_paths.append(ws.by_key['zc.buildout'].location)
            extra_paths.append(ws.by_key['zc.recipe.egg'].location)
            zc.buildout.easy_install.scripts(
                [('zeopack', 'plone.recipe.zeoserver.pack', 'main')],
                self.zodb_ws, options['executable'], options['bin-directory'],
                scripts=zeopack_scripts,
                initialization=arguments_info,
                arguments=', '.join(arg_list),
                relative_paths=self._relative_paths,
                extra_paths=extra_paths + self.module_paths,
                )

        # The backup script, pointing to repozo.py
        repozo = options.get('repozo', None)
        if repozo is None:
            repozo = 'ZODB.scripts.repozo'
            extra_paths = []
        else:
            if not os.path.exists(repozo):
                raise AssertionError(
                    'Custom repozo script not found: %s' % repozo)
            directory, filename = os.path.split(repozo)
            repozo = os.path.splitext(filename)[0]
            extra_paths = [directory]
        zc.buildout.easy_install.scripts(
            [('repozo', repozo, 'main')],
            self.zodb_ws, options['executable'], options['bin-directory'],
            extra_paths = extra_paths + self.module_paths,
            relative_paths=self._relative_paths,
            )

        if sys.platform == 'win32':
            self.install_win32_scripts()

    def install_win32_scripts(self):
        path = self.ws_locations + self.module_paths
        location = self.options['location']

        arguments = {'PYTHON': self.options['executable'],
                     'zodb3_home': self.zodb3_home,
                     'INSTANCE_HOME': location,
                     'PYTHONPATH': os.path.pathsep.join(path),
                     'PACKAGE': 'zeo',
                     'PID_FILENAME': self.pid_file}

        # runzeo.bat
        runzeo_filename = '%s_runzeo.bat' % self.name
        runzeo = open(join(curdir, 'runzeo.bat')).read()
        self._write_file(os.path.join(self.options['bin-directory'],
                                      runzeo_filename), runzeo % arguments)

        # zeoservice.py
        zeo_filename = '%s_service' % self.name
        zeo_service = open(join(curdir, 'zeoservice.py.in')).read()
        zeo_file = os.path.join(self.options['bin-directory'],
                                    '%s.py' % zeo_filename)
        self._write_file(zeo_file, zeo_service % arguments)

        initialization = """
        import os; os.environ['PYTHONPATH'] = %r
        """.strip() % os.path.pathsep.join(path)

        zc.buildout.easy_install.scripts(
            [(zeo_filename, zeo_filename, 'main')],
            self.zodb_ws,
            self.options['executable'],
            self.options['bin-directory'],
            extra_paths = path,
            relative_paths=self._relative_paths,
            initialization = initialization,
            )

    def _write_file(self, path, content):
        logger = logging.getLogger('zc.buildout.easy_install')
        f = open(path, 'w')
        try:
            f.write(content)
        finally:
            f.close()
        logger.debug('Wrote file %s' % path)
        os.chmod(path, 0755)
        logger.warning('Changed mode for %s to 755' % path)


# the template used to build a regular file storage entry for zeo.conf
file_storage_template = """
<filestorage %(storage_number)s>
  path %(file_storage)s
  %(pack_gc)s
  %(pack_keep_old)s
</filestorage>
""".strip()


# the template used to build a blob storage
zodb_version = get_distribution('ZODB3').version

if parse_version(zodb_version) >= parse_version('3.9'):
    # ZODB 3.9+ supports blobs natively
    blob_storage_template = """
<filestorage %(storage_number)s>
  path %(file_storage)s
  blob-dir %(blob_storage)s
  %(pack_gc)s
  %(pack_keep_old)s
</filestorage>
""".strip()

else:
    # ZODB 3.8 needs a blob storage wrapper
    blob_storage_template = """
<blobstorage %(storage_number)s>
  blob-dir %(blob_storage)s
  <filestorage %(storage_number)s>
    path %(file_storage)s
    %(pack_gc)s
    %(pack_keep_old)s
  </filestorage>
</blobstorage>
""".strip()


z_log_file = """\
     <logfile>
      path %(filename)s
      format %(logformat)s
    </logfile>
""".strip()

authentication_template = """
  authentication-protocol digest
  authentication-database %(database)s
  authentication-realm %(realm)s
"""

# The template used to build zeo.conf
zeo_conf_template = """\
%%define INSTANCE %(instance_home)s

<zeo>
  address %(zeo_address)s
  read-only false
  invalidation-queue-size %(invalidation_queue_size)s
  pid-filename %(pid_file)s
  %(authentication)s
  %(monitor_address)s
</zeo>

%(storage)s

<eventlog>
  level %(zeo_log_level)s
  %(z_log)s
</eventlog>

<runner>
  program $INSTANCE/bin/runzeo
  socket-name %(socket_name)s
  daemon true
  forever false
  backoff-limit 10
  exit-codes 0, 2
  directory $INSTANCE
  default-to-interactive true
  %(effective_user)s

  # This logfile should match the one in the zeo.conf file.
  # It is used by zdctl's logtail command, zdrun/zdctl doesn't write it.
  logfile %(z_log_filename)s
</runner>

%(zeo_conf_additional)s
"""