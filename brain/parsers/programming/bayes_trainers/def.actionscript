package org.jamesward.bubblemark
{
  import flash.display.Graphics;
  
  import mx.core.IFactory;
  import mx.core.UIComponent;
  
    public class Ball extends UIComponent {
        
        public var vx:Number = 0;
        public var vy:Number = 0;
        public var d:Number;
        public var d2:Number;       
        
    public var radius:Number;
    public var maxSpeed:Number;
    public var elastity:Number;
    public var renderer:IFactory;
    
        public function Ball() {
      radius = 26;
      maxSpeed = 3;
      elastity = -0.2;
      
            d = 2*radius;
            d2 = d*d;
        }
        
        override protected function createChildren():void
        {
          super.createChildren();
          
          if (renderer != null)
          {
            this.addChild(renderer.newInstance());
          }
          else
          {
            var g:Graphics = graphics;
              g.beginFill(0x0000ff);
              g.drawCircle(26,26,26);
              g.endFill();
            }
        }

    }

}


/**
 * Copyright (c) 2007, Akeem Philbert (based on the work of (between others): Jesse Warden, Xavi Beumala, Renaun 
  Erickson, Carlos Rovira)
  All rights reserved.
*/

package com.ak33m.rpc.xmlrpc
{
  import mx.utils.Base64Encoder;
  import flash.utils.ByteArray;
  import mx.formatters.DateFormatter;
  import mx.utils.Base64Decoder;
  import mx.rpc.Fault;
  import com.ak33m.rpc.core.RPCMessageCodes;
  import flash.xml.XMLNode;
  import flash.xml.XMLDocument;
  
  public class XMLRPCSerializer
  {
    internal static const TYPE_INT:String = "int";
    internal static const TYPE_I4:String = "i4";
    internal static const TYPE_DOUBLE:String = "double";
    internal static const TYPE_STRING:String = "string";
    internal static const TYPE_BOOLEAN:String = "boolean";
    internal static const TYPE_ARRAY:String = "array";
    internal static const TYPE_BASE64:String = "base64";
    internal static const TYPE_STRUCT:String = "struct";
    internal static const TYPE_DATE:String = "dateTime.iso8601";
    
    public function XMLRPCSerializer ()
    {
      
    }
    
    public static function serialize (method:String,params:Array):XML
    {
      var xmlrpc:XML = <methodCall>
                <methodName>{method}</methodName>
               </methodCall>
      if (params.length > 0)
      {
        var tparams:XML = <params></params>
        for each (var param:* in params)
        {
          tparams.appendChild(<param><value>{encodeObject(param)}</value></param>);
        }
        xmlrpc.insertChildAfter(xmlrpc.methodName,tparams);
      }
      
      return xmlrpc;    
    }
    
    protected static function encodeObject (tobject:*):XMLList
    {
      var txmllist:XMLList;
      if (tobject is String)
      {
        txmllist =  encodeString(tobject);
      }
      else if (tobject is Number && Math.floor(tobject)==tobject)
      {
        txmllist =  encodeInteger(tobject);
      }
      else if (tobject is Boolean)
      {
        txmllist =  encodeBoolean(tobject);
      }
      else if (tobject is Number)
      {
        txmllist =  encodeDouble(tobject);
      }
      else if (tobject is Date)
      {
        txmllist =  encodeDate(tobject);
      }
      else if (tobject is Array)
      {
        txmllist =  encodeArray(tobject);
      }
      else if (tobject is IXMLRPCStruct)
      {
        txmllist =  encodeStruct(tobject.getPropertyData());
      }
      else
      {
        txmllist = encodeString(tobject as String);
      }
      
      return txmllist;
    }
    
    protected static function encodeString(rstring:String):XMLList
    {
      return new XMLList("<"+TYPE_STRING+">"+rstring+"</"+TYPE_STRING+">");
    }
    
    protected static function encodeBoolean (rboolean:Boolean):XMLList
    {
      var xmlrpcboolean:String = rboolean ? "1" : "0";
      return new XMLList("<"+TYPE_BOOLEAN+">"+xmlrpcboolean+"</"+TYPE_BOOLEAN+">");
    }
    
    protected static function encodeInteger (rinteger:int):XMLList
    {
      return new XMLList("<"+TYPE_INT+">"+rinteger+"</"+TYPE_INT+">");
    }
    
    protected static function encodeDouble (rdouble:Number):XMLList
    {
      return new XMLList("<"+TYPE_DOUBLE+">"+rdouble+"</"+TYPE_DOUBLE+">");
    }
    
    protected static function encodeDate (rdate:Date):XMLList
    {
      var tdateformatter:DateFormatter = new DateFormatter();
      tdateformatter.formatString = "YYYYMMDDTJJ:NN:SS";
      var tdatestring:String = tdateformatter.format(rdate);
      return new XMLList("<"+TYPE_DATE+">"+tdatestring+"</"+TYPE_DATE+">");
    }
    
    protected static function encodeArray (rarray:Array):XMLList
    {
      var tarrayxml:XML = <array>
                </array>
      var tarraydataxml:XML = <data>
                  </data>
      for (var i:int; i<rarray.length; i++)
      {
        tarraydataxml.appendChild(<value>{encodeObject(rarray[i])}</value>);
      }
      tarrayxml.appendChild(tarraydataxml);
      return new XMLList(tarrayxml);
    }
    
    protected static function encodeBase64 (rbase64:ByteArray):XMLList
    {
      var enc:Base64Encoder = new Base64Encoder();
      enc.encodeBytes(rbase64);
      return new XMLList("<"+TYPE_BASE64+">"+enc.drain()+"</"+TYPE_BASE64+">");
    }
    
    protected static function encodeStruct (rprops:*):XMLList
    {
      var tstructxml:XML = <struct>
                 </struct>
      for (var j:* in rprops)
      {
        tstructxml.appendChild(<member><name>{j}</name><value>{encodeObject(rprops[j])}</value></member>);
      }
      return new XMLList(tstructxml);
    }
    
    public static function deserialize (rxmlresult:XMLDocument):*
    {
      var xmlresult:XML = new XML(rxmlresult.toString());
      var resultvaluexml:XMLList = xmlresult.params.param.value;
      var faultxml:XMLList = xmlresult.fault.value;
      if (resultvaluexml.toString() != "")
      return decodeObject(resultvaluexml);
      else if (faultxml)
      {
        var faultobj:* = decodeObject(faultxml);
        var tfault:Fault = new Fault(faultobj.faultCode,faultobj.faultString);
        return tfault;
      }
      else
      {
        throw new Error(RPCMessageCodes.INVALID_XMLRPCFORMAT);
      }
    }
    
    protected static function decodeObject (robject:*):*
    {
      if (robject.children().name() == TYPE_STRING)
      {
        return String(robject.string);
      }
      else if (robject.children().name() == TYPE_INT)
      {
        return new int(robject.int);
      }
      else if (robject.children().name() == TYPE_I4)
      {
        return new int (robject.i4);
      }
      else if (robject.children().name() == TYPE_BOOLEAN)
      {
        if (isNaN(robject.boolean))
        {
          if (String(robject.boolean).toLowerCase() == "true")
          return true;
          else if (String(robject.boolean).toLowerCase() == "false")
          return false;
          else
          return null;
        }
        else
        {
          return Boolean(Number(robject.boolean));
        }
      }
      else if (robject.children().name()== TYPE_DATE)
      {
        var tdatestring:String = robject.children();
        var datepattern:RegExp = /^(-?\d\d\d\d)-?(\d\d)-?(\d\d)T(\d\d):(\d\d):(\d\d)/;
        var d:Array = tdatestring.match(datepattern);
        var tdate:Date =  new Date(d[1],d[2]-1,d[3],d[4],d[5],d[6]);
        return tdate;
      }
      else if (robject.children().name() == TYPE_BASE64)
      {
        var base64decoder:Base64Decoder = new Base64Decoder();
        base64decoder.decode(robject.base64);
        return base64decoder.flush();
        
      }
      else if (robject.children().name() == TYPE_ARRAY)
      {
        var tarray:Array = new Array();
        for each (var value:* in robject.array.data.value)
        {
          tarray.push(decodeObject(value));
        }
        return tarray;
      }
      else if (robject.children().name() == TYPE_STRUCT)
      {
        var tvalue:Object = new Object();
        for each (var member:* in robject.struct.member)
        {
          tvalue[member.name] = decodeObject(member.value);
        }
        return tvalue;
      }
      else if (robject.children().name() == TYPE_DOUBLE)
      {
        return Number(robject.double);
      }
      else 
      {
        return String(robject);
      }
    }
  }
}

/*********************************************************************************************************************************
 
 Copyright (c) 2007 Ben Stucki
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
 modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
*********************************************************************************************************************************/
package com.benstucki.utilities
{
  import flash.display.BitmapData;
  import flash.display.Loader;
  import flash.display.LoaderInfo;
  import flash.events.Event;
  import flash.geom.Matrix;
  import flash.net.URLRequest;
  import flash.system.LoaderContext;
  import flash.utils.Dictionary;
  
  import mx.containers.accordionClasses.AccordionHeader;
  import mx.controls.tabBarClasses.Tab;
  import mx.core.BitmapAsset;
  import mx.core.UIComponent;
  
  /**
   * Provides a workaround for using run-time loaded graphics in styles and properties which require a Class reference
   */
  public class IconUtility extends BitmapAsset
  {
    
    private static var dictionary:Dictionary;
    
    /**
     * Used to associate run-time graphics with a target
     * @param target A reference to the component associated with this icon
     * @param source A url to a JPG, PNG or GIF file you wish to be loaded and displayed
     * @param width Defines the width of the graphic when displayed
     * @param height Defines the height of the graphic when displayed
     * @return A reference to the IconUtility class which may be treated as a BitmapAsset
     * @example &lt;mx:Button id="button" icon="{IconUtility.getClass(button, 'http://www.yourdomain.com/images/test.jpg')}" /&gt;
     */
    public static function getClass( target:UIComponent, source:String, width:Number = NaN, height:Number = NaN ):Class {
      if(!dictionary) {
        dictionary = new Dictionary(false);
      }
      //if(source is String) {
        var loader:Loader = new Loader();
        loader.load(new URLRequest(source as String), new LoaderContext(true));
        //source = loader;
      //}
      dictionary[target] = { source:loader, width:width, height:height };
      return IconUtility;
    }
    
    /**
     * @private
     */
    public function IconUtility():void {
      addEventListener(Event.ADDED, addedHandler, false, 0, true)
    }
    
    private function addedHandler(event:Event):void {
      if(parent) {
        if(parent is AccordionHeader) {
          var header:AccordionHeader = parent as AccordionHeader;
          getData(header.data);
        } else if(parent is Tab) {
          var tab:Tab = parent as Tab;
          getData(tab.data);
        } else {
          getData(parent);
        }
      }
    }
    
    private function getData(object:Object):void {
      var data:Object = dictionary[object];
      if(data) {
        var source:Object = data.source;
        if(data.width > 0 && data.height > 0) {
          bitmapData = new BitmapData(data.width, data.height, true, 0x00FFFFFF);
        }
        if(source is Loader) {
          var loader:Loader = source as Loader;
          if(!loader.content) {
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler, false, 0, true);
          } else {
            displayLoader(loader);
          }
        }
      }
    }
    
    private function displayLoader( loader:Loader ):void {
      if(!bitmapData) {
        bitmapData = new BitmapData(loader.content.width, loader.content.height, true, 0x00FFFFFF);
      }
      bitmapData.draw(loader, new Matrix(bitmapData.width/loader.width, 0, 0, bitmapData.height/loader.height, 0, 0));
      if(parent is UIComponent) {
        var component:UIComponent = parent as UIComponent;
        component.invalidateSize();
      }
    }
    
    private function completeHandler(event:Event):void {
      if(event && event.target && event.target is LoaderInfo) {
        displayLoader(event.target.loader as Loader);
      }
    }
    
  }
}

package com.launch.elements {
    import com.launch.desktop.appWindow;
    
    import flash.events.Event;
    import flash.events.TimerEvent;
    import flash.utils.Timer;
    
    import mx.binding.utils.ChangeWatcher;
    import mx.containers.Canvas;
    import mx.containers.VBox;
    import mx.containers.ViewStack;
    import mx.controls.Label;
    import mx.core.UIComponent;
    import mx.events.FlexEvent;


    public class htmlControl extends Canvas {
        
        // variables
        [Bindable] public var elementType:String        = 'iframe';
        [Bindable] public var source:String             = null;
        [Bindable] public var showPauseNotice:Boolean   = true;
        [Bindable] private var htmlText:String          = ' ';
        [Bindable] public var windowParent:UIComponent  = null; /*REQUIRED*/
        [Bindable] public var viewStackElement:Object   = null; // This will be set to a viewstack "child" which will be tested for visibility before changing the visibility of the htmlcomp.
        
        private var refreshTimer : Timer = new Timer(150);
        
        // objects
        private var htmlComp:lHtmlComp = new lHtmlComp();
        public var pauseContainer:Canvas    = new Canvas();
        
        
        public function htmlControl()
        {
            super();
            
            // defaults
            this.percentHeight  = 100;
            this.percentWidth   = 100;
            
            this.addEventListener(FlexEvent.CREATION_COMPLETE,creationCompleteHandler);
        }
        
        
        public function set text(strText:String) : void {
            this.htmlText = strText;
            
            // We want to try to set the html from here, but if the component hasn't been created yet, we can't.
            try { this.htmlComp.htmlText = strText }
            catch (e:Error) { /* NOTHING HERE */ }
            
        }
        
        
        public function get text() : String {
            return this.htmlComp.getHTML();
        }
        
        
        public function removeElement() : void {
            this.htmlComp.removeElement();
        }
        
        
        public function creationCompleteHandler(event:FlexEvent = null) : void {    
            
            // add the htmlComp
            this.createHtmlComp();
            
            // add the pause notice
            this.createPauseNotice();
            
            // add eventListeners
            this.createEventListeners();
            
            // Change watchers
            ChangeWatcher.watch(this, "elementType", updateElementType);
            ChangeWatcher.watch(this, "source", updateSource);
            ChangeWatcher.watch(this, "windowParent", updateWindowParent);
            
        }
        
        
        
        public function createHtmlComp() : void {
            // Dynamically generating an "id" for our component because it's what the htmlComponent uses to identify itself from other htmlComponents that may be present
            var randomID:String = "hcFileComponent_" + ( Math.round( (Math.random()*1000) * (Math.random()*1000) * (Math.random()*1000) ) ) ;
            this.htmlComp.id            = randomID;
            this.htmlComp.name          = randomID;
            this.htmlComp.elementType   = this.elementType;
            this.htmlComp.source        = this.source;
            this.htmlComp.percentHeight = 100;
            this.htmlComp.percentWidth  = 100;
            this.htmlComp.htmlText      = 'Loading...';
            
            // add the htmlComp
            this.addChild(this.htmlComp);
            
            this.htmlComp.addEventListener("htmlCreationComplete", htmlCompLoaded);
        }
        
        private function htmlCompLoaded(e:Event) : void {
            this.htmlComp.htmlText = this.htmlText;
            this.htmlComp.setVisibility(true);
        }
        
        
        private function createPauseNotice() : void {
            // paused bg container
            pauseContainer.visible                  = false;
            pauseContainer.styleName                = 'htmlPausedContainer';
            pauseContainer.percentHeight            = 100;
            pauseContainer.percentWidth             = 100;
            pauseContainer.verticalScrollPolicy     = 'off';
            pauseContainer.horizontalScrollPolicy   = 'off';
            
            // little container
            var pauseNotice:VBox    = new VBox();
            pauseNotice.styleName   = 'htmlPausedNotice';
            
            // Paused Text
            var pText:Label = new Label();
            pText.text      = 'Paused';
            pText.styleName = 'htmlPausedText';
            
            // Sub Text
            var subText:Label   = new Label();
            subText.text        = 'Click to resume';
            subText.styleName   = 'htmlPausedSubText';
            
            // add the pause notice
            
            pauseNotice.addChild(pText);
            pauseNotice.addChild(subText);
            pauseContainer.addChild(pauseNotice);
            this.addChild(this.pauseContainer);
        }
        
        
        private function createEventListeners() : void {
            if (windowParent != null && this.windowParent is appWindow) {
                // window event listeners
                var wparent:appWindow = windowParent as appWindow;
                wparent.addEventListener("MOVED", windowDragHandler);
                wparent.addEventListener("CLOSED", windowCloseHandler);
                wparent.addEventListener("MINIMIZED", windowHideHandler);
                wparent.addEventListener("FOCUSED", windowShowHandler);
                wparent.addEventListener("UNFOCUSED", windowHideHandler);
                wparent.addEventListener("RESTORED", windowShowHandler);
                
                // dockbar event listeners
                this.parentApplication.dockbar.addEventListener("MENUOPENED", windowHideHandler);
                this.parentApplication.dockbar.addEventListener("MENUCLOSED", windowShowHandler);

            }

        }
        
        
        private function windowDragHandler(event:Event) : void {
            // refresh the HtmlComp's position
            this.htmlComp.refreshElement();
        }
        
        private function windowCloseHandler(event:Event) : void {
            // remove the htmlComp
            this.htmlComp.removeElement();
            this.destroyEventListeners();
        }
        
        public function windowHideHandler(event:Event=null) : void {
            
            var wparent:appWindow = this.windowParent as appWindow;
            
            trace(wparent.title + ": testing hide event");
            
            // Making sure the viewstack element is currently selected if it's set.
            if ( this.viewStackElement != null && this.viewStackElement.parent is ViewStack && this.viewStackElement.parent.selectedChild != this.viewStackElement ) return;
            
            // show the paused notice
            this.pauseContainer.visible = true;
            
            // hide the hComp
            this.htmlComp.visible = false;
            this.htmlComp.setVisibility(false); 
            trace(wparent.title + ": hiding");
        }
        
        
        
        public function windowShowHandler(event:Event=null) : void {
            
            var wparent:appWindow = this.windowParent as appWindow;
            //trace("Title: " + wparent.title);
            trace(wparent.title + ": testing show event");
            
            //trace("hasFocus: " + wparent.hasFocus);
            // Making sure the viewstack element is currently selected if it's set.
            if ( this.viewStackElement != null && this.viewStackElement.parent is ViewStack && this.viewStackElement.parent.selectedChild != this.viewStackElement ) return;
            
            //if the window does not have focus, re-hide the html comp
            /*if(wparent.hasFocus == false) {
                this.htmlComp.visible = false;
                this.pauseContainer.visible = true;
            }*/ 
            
            // if the window is not minimized & has focus
            if(wparent.minimized != true && wparent.hasFocus == true) {
                trace(wparent.title + ": showing");
                // hide the paused notice 
                this.pauseContainer.visible = false;
                // show the hComp
                this.htmlComp.visible = true;
                this.htmlComp.setVisibility(true);
                
                this.refreshTimer.addEventListener(TimerEvent.TIMER, refreshElement);
                this.refreshTimer.start();
            }
        }
        
        
        
        private function refreshElement(event:TimerEvent) : void {
            // refresh the HtmlComp's position
            callLater(this.htmlComp.refreshElement);
            this.refreshTimer.reset();
        }
        
        
        
        private function destroyEventListeners() : void {
            // remove all event listeners
            var wparent:appWindow = this.windowParent as appWindow;
            wparent.removeEventListener("MOVED", windowDragHandler);
            wparent.removeEventListener("CLOSED", windowCloseHandler);
            wparent.removeEventListener("MINIMIZED", windowHideHandler);
            wparent.removeEventListener("FOCUSED", windowShowHandler);
            wparent.removeEventListener("UNFOCUSED", windowHideHandler);
            wparent.removeEventListener("RESTORED", windowShowHandler);
            
            // dockbar event listeners
            this.parentApplication.dockbar.removeEventListener("MENUOPENED", windowHideHandler);
            this.parentApplication.dockbar.removeEventListener("MENUCLOSED", windowShowHandler);
        }
        
        
        
        //-------------------------------------
        // change watcher functions
        //-------------------------------------
        
        public function updateWindowParent(event:Event) : void {
            // if the windowParent var changes create new eventListeners
            this.destroyEventListeners();
            this.createEventListeners();
        }
        
        public function updateSource(event:Event) : void {
            this.htmlComp.source = this.source;
        }
        
        /*public function updateHtmlText(event:Event) : void {
            this.htmlComp.htmlText = this.text.toString();
        }*/
        
        public function updateElementType(event:Event) : void {
            // destroy the existing htmlComp and create a new one
            if(this.htmlComp)
            {
                // remove the iframe
                this.htmlComp.removeElement();
                
                // remove the htmlComp component
                this.removeAllChildren();
                
                // destroy event listeners
                this.destroyEventListeners();
                
                // create the new components.
                this.creationCompleteHandler();
            }
        }
        
    }
    
}

package com.launch.desktop
{
    import com.launch.elements.htmlControl;
    
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.geom.Point;
    
    import mx.binding.utils.*;
    import mx.containers.HBox;
    import mx.containers.Panel;
    import mx.controls.Button;
    import mx.core.Application;
    import mx.effects.Fade;
    import mx.effects.Pause;
    import mx.events.EffectEvent;
    import mx.events.FlexEvent;
    import mx.events.ModuleEvent;
    import mx.managers.CursorManager;
    import mx.modules.ModuleLoader;
    
    // events
    [Event(name="FOCUSED",      type="flash.events.Event")]
    [Event(name="UNFOCUSED",    type="flash.events.Event")]
    [Event(name="MOVED",        type="flash.events.Event")]
    [Event(name="MINIMIZED",    type="flash.events.Event")]
    [Event(name="MAXIMIZED",    type="flash.events.Event")]
    [Event(name="RESTORED",     type="flash.events.Event")]
    [Event(name="RESIZED",      type="flash.events.Event")]
    [Event(name="CLOSED",       type="flash.events.Event")]

    public class appWindow extends Panel
    {
        
        /*------------------------------------------------
            Variables
        ------------------------------------------------*/
        [Embed(source="/assets/skins/windows/resizeCursor.png")]
        private static var resizeCursor:Class;
        
        private var oW:Number;
        private var oH:Number;
        private var oX:Number;
        private var oY:Number;
        [Bindable] public var xPos:*;
        [Bindable] public var yPos:*;
        [Bindable] public var showControls:Boolean  = true;
        [Bindable] public var resizable:Boolean     = false;
        [Bindable] public var draggable:Boolean     = true; // depreciated - can remove in future
        [Bindable] public var hasFocus:Boolean      = false;
        [Bindable] public var minimized:Boolean     = false;
        [Bindable] public var maximized:Boolean     = false;
        private var btnBox:HBox                     = new HBox();
        private var minimizeButton:Button           = new Button();
        private var normalMaxButton:Button          = new Button();
        private var closeButton:Button              = new Button();
        private var resizeHandler:Button            = new Button();
        private var oPoint:Point                    = new Point();
        private var resizeCur:Number                = 0;
        public var passedVars:*                     = null;
        public var moduleName:String                = ""; // the name of the application we want to load into the moduleLoader
        public var displayName:String               = "";
        public var isWebWindow:Boolean              = new Boolean(false);
        
        
        /*------------------------------------------------
            Constructor
        ------------------------------------------------*/
        public function appWindow()
        {
            super();
            
            this.alpha = 0;
            this.x = -10000;
            this.y = -10000;
            
            this.addEventListener(FlexEvent.CREATION_COMPLETE, creationCompleteHandler);
        }
        
        
        override protected function createChildren():void {
            super.createChildren();

            if (showControls) {
                this.btnBox.width               = 67;
                this.btnBox.height              = 22;
                this.btnBox.styleName           = "btnBoxFocused";
                this.minimizeButton.width       = 19;
                this.minimizeButton.height      = 22;
                this.minimizeButton.styleName   = "minimizeBtn";
                this.normalMaxButton.width      = 19;
                this.normalMaxButton.height     = 22;
                this.normalMaxButton.styleName  = "increaseBtn";
                this.closeButton.width          = 19;
                this.closeButton.height         = 22;
                this.closeButton.styleName      = "closeBtn";
                this.btnBox.addChild(this.minimizeButton);
                this.btnBox.addChild(this.normalMaxButton);
                this.btnBox.addChild(this.closeButton);
                super.titleBar.addChild(this.btnBox);
            }
            

            if(!resizable) {
                this.resizeHandler.visible   = false;
            }
            this.resizeHandler.width     = 14;
            this.resizeHandler.height    = 15;
            this.resizeHandler.styleName = "resizeHndlr";
            this.rawChildren.addChild(resizeHandler);
            this.initPos();
            
        }
        
        
        /*------------------------------------------------
            IntPos - save old height and width
        ------------------------------------------------*/
        public function initPos():void {

            this.oW = this.width;
            this.oH = this.height;
            this.oX = this.x;
            this.oY = this.y;
        }
        
        
        /*------------------------------------------------
            UpdateDisplayList
        ------------------------------------------------*/
        override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void {
            super.updateDisplayList(unscaledWidth,unscaledHeight);
            this.positionChildren();
        }
        
        
        /*------------------------------------------------
            PositionChildren - initial layout of controls
        ------------------------------------------------*/
        public function positionChildren():void {

            if (showControls) {
                this.minimizeButton.buttonMode      = true
                this.minimizeButton.useHandCursor   = true;
                this.normalMaxButton.buttonMode     = true;
                this.normalMaxButton.useHandCursor  = true;
                this.closeButton.buttonMode         = true;
                this.closeButton.useHandCursor      = true;
                this.btnBox.x                       = this.unscaledWidth - this.btnBox.width;
                this.btnBox.y                       = 0;
            }

            this.resizeHandler.y = this.unscaledHeight - resizeHandler.height - 1;
            this.resizeHandler.x = this.unscaledWidth - resizeHandler.width - 1;
            this.resizeHandler.visible = true;
        }
        
        
        /*------------------------------------------------
            CreationCompleteHandler
        ------------------------------------------------*/
        public function creationCompleteHandler(event:Event):void {
            
            BindingUtils.bindProperty(this, "x", this, "xPos");
            BindingUtils.bindProperty(this, "y", this, "yPos");
            ChangeWatcher.watch(this,"xPos",updateXPos);
            ChangeWatcher.watch(this,"yPos",updateYPos);
            
            // if this is a module application
            if (this.moduleName != "" && !this.isWebWindow) {
                // create moduleLoader
                createModuleLoader();
            }
            // if this is a web window
            else if (this.isWebWindow) {
                createWebWindow(event);
            }
            
            //add event handlers
            this.addEventHandlers();
            
            // focus Window
            this.focusWindow();
            
            // update current values
            this.initPos();
        }
        
        
        
        /*------------------------------------------------
            Create Module Loader
        ------------------------------------------------*/
        [Bindable] private var appModule:ModuleLoader = new ModuleLoader();
        private function createModuleLoader(event:* = null):void
        {
            /*
                Create a new ModuleLoader and pass it the application module to load,
                load the module, add the module loader to the appContainer. the moduleLoader
                is the same height and width as the appContainer.
            */
            
            this.appModule.url                          = this.moduleName + ".swf";
            this.appModule.percentHeight                = 100;
            this.appModule.percentWidth                 = 100;
            this.appModule.horizontalScrollPolicy       = "off";
            this.appModule.verticalScrollPolicy         = "off";
            this.appModule.inheritingStyles             = null;
            this.appModule.addEventListener(ModuleEvent.READY, moduleLoaded);
                        
            // add the module Loader
            this.addChild(this.appModule);
            
        }
        
        
        
        /*------------------------------------------------
            Create Web Window
        ------------------------------------------------*/
        private function createWebWindow(event:Event):void
        {   
            var htmlCont:htmlControl    = new htmlControl();
            htmlCont.elementType        = 'iframe';
            htmlCont.source             = this.passedVars.url;
            htmlCont.windowParent       = this; 
            
            // styles
            htmlCont.setStyle('top',5);
            htmlCont.setStyle('right',5);
            htmlCont.setStyle('bottom',20);
            htmlCont.setStyle('left',5);
            htmlCont.addEventListener(FlexEvent.CREATION_COMPLETE, htmlContComplete);
            
            // window settings
            this.layout     = 'absolute';
            this.height     = this.passedVars.height;
            this.width      = this.passedVars.width;
            this.title      = this.passedVars.app_name + " - " + this.passedVars.url;
            this.resizable  = true;
            
            this.addChild(htmlCont);
            
        }
        
    }
}

package com.dougmccune.coverflow.materials
{
    import flash.display.BitmapData;
    import flash.display.BlendMode;
    import flash.display.DisplayObject;
    import flash.display.GradientType;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    
    import org.papervision3d.materials.MovieMaterial;
    
    public class ReflectionMaterial extends MovieMaterial
    {
        
        public function ReflectionMaterial(movieAsset:DisplayObject=null, transparent:Boolean=true, animated:Boolean=true)
        {
            super(movieAsset, transparent, animated);   
        }
        
        /**
         * Basically we're flipping the image vertically, then drawing a gradient over it and drawing that using
         * the ALPHA blend mode.
         */
        override public function drawBitmap():void {
            
            var mtx:Matrix = new Matrix();
            mtx.scale( movie.scaleX, -movie.scaleY );
            mtx.translate(0, movie.height);
            
            bitmap.draw( movie, mtx, movie.transform.colorTransform, BlendMode.LAYER );
    
            var sprite:Sprite = new Sprite();
            
            var alphas:Array = [0, .2];
            var ratios:Array = [150, 255];
            var matr:Matrix = new Matrix();
            matr.createGradientBox(bitmap.width, bitmap.height, Math.PI/2, 0, 0);
            
            sprite.graphics.beginGradientFill(GradientType.LINEAR, [0x000000, 0x000000], alphas, ratios, matr);  
            sprite.graphics.drawRect(0,0,bitmap.width,bitmap.height);
            
            bitmap.draw(sprite, mtx, null, BlendMode.ALPHA);
        }
        
        
    }
}

package com.adobe.ac.controls
{
  import com.adobe.ac.mxeffects.Distortion;
  import com.adobe.ac.mxeffects.DistortionConstants;
  
  import flash.display.DisplayObject;
  
  import mx.containers.Canvas;
  import mx.core.UIComponent;
  import mx.events.FlexEvent;
  
  public class ViewStack3D extends Canvas
  {
    private var distortions : Array = new Array();
    
    public function ViewStack3D()
    {
      addEventListener( FlexEvent.CREATION_COMPLETE, initDistortions );
    }
    
    private function initDistortions( event : FlexEvent ) : void
    {     
      for( var i : int; i < numChildren; i++ )
      {
        var child : UIComponent = UIComponent( getChildAt( i ) );
        initialiseBounds( child );
        
        var distort : Distortion = new Distortion( child );
        distort.smooth = true;
        distort.openDoor( 40, DistortionConstants.LEFT );
        distortions.push( distort );
      }
    }
    
    override protected function createChildren() : void
    {
      super.createChildren();
      for( var i : int; i < numChildren; i++ )
      {
        var child : UIComponent = UIComponent( getChildAt( i ) );
        child.x += i * 25;
        child.y += i * 20;        
      } 
    }
    
    public function tilt( percentage : Number ) : void
    {
      var len : Number = distortions.length;
      for( var i : int; i < len; i++ )
      {
        var distort : Distortion = distortions[ i ];
        distort.openDoor( percentage, DistortionConstants.LEFT );
      }
    }
    
    private function initialiseBounds( texture : UIComponent ) : void
    {   
      var firstChild : DisplayObject = DisplayObject( getChildAt( 0 ) );
      texture.setActualSize( firstChild.width, firstChild.height );
      texture.validateNow();    
    }
  }
}

/*
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.adobe.crypto
{
  import com.adobe.utils.IntUtil;
  import flash.utils.ByteArray;
  import mx.utils.Base64Encoder;
  
  /**
   * The SHA-256 algorithm
   * 
   * @see http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf
   */
  public class SHA256
  {
    public static var digest:ByteArray;
    /**
     *  Performs the SHA256 hash algorithm on a string.
     *
     *  @param s    The string to hash
     *  @return     A string containing the hash value of s
     *  @langversion  ActionScript 3.0
     *  @playerversion  9.0
     *  @tiptext
     */
    public static function hash( s:String ):String {
      var blocks:Array = createBlocksFromString( s );
      var byteArray:ByteArray = hashBlocks( blocks );
      
      return IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true );
    }
    
    /**
     *  Performs the SHA256 hash algorithm on a ByteArray.
     *
     *  @param data   The ByteArray data to hash
     *  @return     A string containing the hash value of data
     *  @langversion  ActionScript 3.0
     *  @playerversion  9.0
     */
    public static function hashBytes( data:ByteArray ):String
    {
      var blocks:Array = createBlocksFromByteArray( data );
      var byteArray:ByteArray = hashBlocks(blocks);
      
      return IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true )
          + IntUtil.toHex( byteArray.readInt(), true );
    }
    
    /**
     *  Performs the SHA256 hash algorithm on a string, then does
     *  Base64 encoding on the result.
     *
     *  @param s    The string to hash
     *  @return     The base64 encoded hash value of s
     *  @langversion  ActionScript 3.0
     *  @playerversion  9.0
     *  @tiptext
     */
    public static function hashToBase64( s:String ):String
    {
      var blocks:Array = createBlocksFromString( s );
      var byteArray:ByteArray = hashBlocks(blocks);

      // ByteArray.toString() returns the contents as a UTF-8 string,
      // which we can't use because certain byte sequences might trigger
      // a UTF-8 conversion.  Instead, we convert the bytes to characters
      // one by one.
      var charsInByteArray:String = "";
      byteArray.position = 0;
      for (var j:int = 0; j < byteArray.length; j++)
      {
        var byte:uint = byteArray.readUnsignedByte();
        charsInByteArray += String.fromCharCode(byte);
      }

      var encoder:Base64Encoder = new Base64Encoder();
      encoder.encode(charsInByteArray);
      return encoder.flush();
    }
    
    private static function hashBlocks( blocks:Array ):ByteArray {
      var h0:int = 0x6a09e667;
      var h1:int = 0xbb67ae85;
      var h2:int = 0x3c6ef372;
      var h3:int = 0xa54ff53a;
      var h4:int = 0x510e527f;
      var h5:int = 0x9b05688c;
      var h6:int = 0x1f83d9ab;
      var h7:int = 0x5be0cd19;
      
      var k:Array = new Array(0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2);
      
      var len:int = blocks.length;
      var w:Array = new Array( 64 );
      
      // loop over all of the blocks
      for ( var i:int = 0; i < len; i += 16 ) {
        
        var a:int = h0;
        var b:int = h1;
        var c:int = h2;
        var d:int = h3;
        var e:int = h4;
        var f:int = h5;
        var g:int = h6;
        var h:int = h7;
        
        for(var t:int = 0; t < 64; t++) {
          
          if ( t < 16 ) {
            w[t] = blocks[ i + t ];
            if(isNaN(w[t])) { w[t] = 0; }
          } else {
            var ws0:int = IntUtil.ror(w[t-15], 7) ^ IntUtil.ror(w[t-15], 18) ^ (w[t-15] >>> 3);
            var ws1:int = IntUtil.ror(w[t-2], 17) ^ IntUtil.ror(w[t-2], 19) ^ (w[t-2] >>> 10);
            w[t] = w[t-16] + ws0 + w[t-7] + ws1;
          }
          
          var s0:int = IntUtil.ror(a, 2) ^ IntUtil.ror(a, 13) ^ IntUtil.ror(a, 22);
          var maj:int = (a & b) ^ (a & c) ^ (b & c);
          var t2:int = s0 + maj;
          var s1:int = IntUtil.ror(e, 6) ^ IntUtil.ror(e, 11) ^ IntUtil.ror(e, 25);
          var ch:int = (e & f) ^ ((~e) & g);
          var t1:int = h + s1 + ch + k[t] + w[t];
          
          h = g;
          g = f;
          f = e;
          e = d + t1;
          d = c;
          c = b;
          b = a;
          a = t1 + t2;
        }
          
        //Add this chunk's hash to result so far:
        h0 += a;
        h1 += b;
        h2 += c;
        h3 += d;
        h4 += e;
        h5 += f;
        h6 += g;
        h7 += h;
      }
      
      var byteArray:ByteArray = new ByteArray();
      byteArray.writeInt(h0);
      byteArray.writeInt(h1);
      byteArray.writeInt(h2);
      byteArray.writeInt(h3);
      byteArray.writeInt(h4);
      byteArray.writeInt(h5);
      byteArray.writeInt(h6);
      byteArray.writeInt(h7);
      byteArray.position = 0;
      
      digest = new ByteArray();
      digest.writeBytes(byteArray);
      digest.position = 0;
      return byteArray;
    }
    
    /**
     *  Converts a ByteArray to a sequence of 16-word blocks
     *  that we'll do the processing on.  Appends padding
     *  and length in the process.
     *
     *  @param data   The data to split into blocks
     *  @return     An array containing the blocks into which data was split
     */
    private static function createBlocksFromByteArray( data:ByteArray ):Array
    {
      var oldPosition:int = data.position;
      data.position = 0;
      
      var blocks:Array = new Array();
      var len:int = data.length * 8;
      var mask:int = 0xFF; // ignore hi byte of characters > 0xFF
      for( var i:int = 0; i < len; i += 8 )
      {
        blocks[ i >> 5 ] |= ( data.readByte() & mask ) << ( 24 - i % 32 );
      }
      
      // append padding and length
      blocks[ len >> 5 ] |= 0x80 << ( 24 - len % 32 );
      blocks[ ( ( ( len + 64 ) >> 9 ) << 4 ) + 15 ] = len;
      
      data.position = oldPosition;
      
      return blocks;
    }
          
    /**
     *  Converts a string to a sequence of 16-word blocks
     *  that we'll do the processing on.  Appends padding
     *  and length in the process.
     *
     *  @param s  The string to split into blocks
     *  @return   An array containing the blocks that s was split into.
     */
    private static function createBlocksFromString( s:String ):Array
    {
      var blocks:Array = new Array();
      var len:int = s.length * 8;
      var mask:int = 0xFF; // ignore hi byte of characters > 0xFF
      for( var i:int = 0; i < len; i += 8 ) {
        blocks[ i >> 5 ] |= ( s.charCodeAt( i / 8 ) & mask ) << ( 24 - i % 32 );
      }
      
      // append padding and length
      blocks[ len >> 5 ] |= 0x80 << ( 24 - len % 32 );
      blocks[ ( ( ( len + 64 ) >> 9 ) << 4 ) + 15 ] = len;
      return blocks;
    }
  }
}

/**
 * Copyright (c) 2007, Akeem Philbert (based on the work of (between others): Jesse Warden, Xavi Beumala, Renaun 
    Erickson, Carlos Rovira)
    All rights reserved.
*/

package com.ak33m.rpc.core
{
    import flash.net.NetConnection;
    import flash.net.ObjectEncoding;
    import flash.net.Responder;
    import flash.utils.*;
    import mx.rpc.*;
    import mx.managers.CursorManager;
    import mx.collections.ArrayCollection;
    import mx.rpc.mxml.IMXMLSupport;
    import mx.rpc.events.*;
    import com.ak33m.rpc.core.*;
    import com.ak33m.rpc.amf0.*;
    import mx.messaging.messages.IMessage;
    import mx.messaging.messages.RemotingMessage;
    import flash.events.Event;
    use namespace flash_proxy;
    
    //EVENTS
    [Event (name="result", type="mx.rpc.events.ResultEvent")]
    [Event (name="fault", type="mx.rpc.events.FaultEvent")]
    [Event (name="invoke", type="mx.rpc.events.InvokeEvent")]
    
    [Bindable]
    
    /**
     * @author Akeem Philbert <akeemphilbert@gmail.com>
     * @author Carlos Rovira <carlos.rovira@gmail.com>
     * The AMF0RemoteObject lets you invoke commands on a  RPC Server that uses the AMF0 format (e.g. Flash Remoting MX, AMFPHP 1.0).
     * It mimics the built in RemoteObject and can be accessed from both MXML and actionscript 3.0 
     */
    dynamic public class AbstractRPCObject extends AbstractService implements IMXMLSupport
    {
        public static const MULTIPLE : String = "multiple";
        public static const SINGLE : String = "single";
        public static const LAST : String = "last";
        
        //private var _gateway:IRPCConnection = null;
        protected var _isbusy:Boolean = false;
        protected var _appservername:String;
        [ArrayElementType("Responder")]
        protected var _responders:ArrayCollection;
        protected var _requestTimeout:Number = 0;
        protected var _showBusyCursor:Boolean = false;
        protected var _destination:String;
        protected var _concurrency:String = "multiple";
        protected var _endpoint:String;
        protected var _id:String;
        protected var _view:Object;
        public var call:Function;
        public var method:*;
        private var _respondercounter:int = 0;
        
        function AbstractRPCObject ()
        {
            super();
            this._responders = new ArrayCollection();
            this.call = this.callProperty;
        }
        
        //GETTERS AND SETTERS
        protected final function getAccess():AbstractRestriction
        {
            return new AbstractRestriction();
        }
        /**
        *@inheritDoc
        */
        public function get showBusyCursor ():Boolean
        {
            return this._showBusyCursor;
        }
        
        /**
        *If <code>true</code>, a busy cursor is displayed while a service is executing. The default value is <code>false.</code>
        */
        public function set showBusyCursor (showcursor:Boolean):void
        {
            this._showBusyCursor = showcursor;
        }
        
        /**
        * Value that indicates how to handle multiple calls to the same service.
        * 
        * <p>
        * The following values are permitted:
        * <ul>
        *   <li><code>AMF0RemoteObject.MULTIPLE</code>. Existing requests are not cancelled, and the developer is responsible for ensuring the consistency of returned data by carefully managing the event stream. This is the default.</li>
        *   <li><code>AMF0RemoteObject.SINGLE</code>. Only a single request at a time is allowed on the operation; multiple requests generate a fault.</li>
        *   <li><code>AMF0RemoteObject.LAST</code>. Making a request cancels any existing request.</li>
        * </ul>
        */
        public function get concurrency ():String
        {
            return this._concurrency;
        }
        
        
        public function set concurrency (concurrency:String):void
        {
            this._concurrency = concurrency;
        }
        
        public function set endpoint(name:String):void
        {
            this._endpoint = name;
        }
        
       
       public function get endpoint():String
        {
            return _endpoint;
        }
        
       override public function set destination (destination:String):void
        {
            this._destination = destination;
        }
        
       override public function get destination():String
       {
            return this._destination;
       }
    
        /**
        * @inheritDoc
        */
        override public function set requestTimeout(value:int):void
        {
            this._requestTimeout = Math.max(0,value);
        }
        
        /**
        * @inheritDoc
        */
        override public function get requestTimeout():int
        {
            return this._requestTimeout;
        }
        
        /**
        * Overrides the behavior of an object property that can be called as a function. 
        */
        flash_proxy override function callProperty (method : *,... args) : *
        {
            switch (this.concurrency)
            {
                case AbstractRPCObject.SINGLE :
                if (_isbusy)
                {
                    throw new Fault(RPCMessageCodes.CONCURRENCY_SINGLE,"The method \""+method+"\" could not be executed because an existing request is being processed");
                }                    
                break;
                case AbstractRPCObject.LAST :
                if (_isbusy)
                {
                   this._responders = new ArrayCollection();
                }
                return makeCall(method,args);
                break;
                case AbstractRPCObject.MULTIPLE :
                return makeCall(method,args);
                break;
                default:
                throw new Error ('concurrency must be: single, multiple or last');
                break;
            }
        }
        
        /**
        * This is where the RPC function call implemntation should be placed. 
        */
        protected function makeCall (method : String,args : Array): AsyncToken
        {
            var tmessage:RemotingMessage = new RemotingMessage();
            tmessage.operation = method;
            tmessage.destination = this.destination;
            var ttoken:AsyncToken = new AsyncToken(tmessage);
            var responder:RPCResponder = new RPCResponder (ttoken);
            responder.timeout = this.requestTimeout;
            responder.addEventListener(RPCEvent.EVENT_RESULT,this.onResult);
            responder.addEventListener(RPCEvent.EVENT_FAULT,this.onFault);
            responder.addEventListener(RPCEvent.EVENT_CANCEL,this.onRemoveResponder);
            _responders.addItem(responder);
            var params : Array = args;
             //Show Busy cursor 
             this.respondercounter++;
            return ttoken;
        }
        
        protected function onRemoveResponder (event:Event):void //This method should be deprecated
        {
            //this._responders.removeItemAt(this._responders.getItemIndex(event.target));
        }
        /**
        * RPCEvent result handler. This dispatches a result event and invokes the result function of the responders in the RPC token
        */
        protected function onResult (evt:RPCEvent):void
        {
            var token:AsyncToken = evt.target.token;
            token.message.body = evt.data;
            var resultevent:ResultEvent = new ResultEvent(ResultEvent.RESULT,true,true,evt.data,token,token.message);
            dispatchEvent(resultevent);
            if (token.hasResponder())
            {
                for (var i:int; i<token.responders.length; i++)
                {
                    token.responders[i].result.call(token.responders[i],resultevent);
                }
            }
            this.respondercounter--;
        }
        
        /**
         * RPCEvent fault handler. This dispatchers a fault event and invokes the fault function of the responders in the RPC token
         */
        protected function onFault (evt:RPCEvent):void
        {
            var token:AsyncToken = evt.target.token;
            token.message.body = evt.data;
            var tfault:Fault;
            if (evt.data.faultCode && evt.data.faultString)
            tfault = new Fault(evt.data.faultCode,evt.data.faultString,evt.data.faultDetail);
            else
            tfault = new Fault(evt.data.code,evt.data.description,evt.data.details);
            var faultevent:FaultEvent = new FaultEvent(FaultEvent.FAULT,true,true,tfault,token,token.message);
            dispatchEvent(faultevent);
            if (token.hasResponder())
            {
                for (var i:int; i<token.responders.length; i++)
                {
                    token.responders[i].fault.call(token.responders[i],faultevent);
                }
            }
            this.respondercounter--;
        }
        
        public function initialized(view:Object,id:String):void
        {
            this._view = view;
            this._id = id;
            trace (id);
        }
        
        protected function send ():void
        {
            
        }
        
        protected function set respondercounter (counter:int):void
         {
            this._respondercounter = counter;
            if (this._respondercounter ==0)
            {
                CursorManager.removeBusyCursor();
                this._isbusy = false;
                //CursorManager.hideCursor();
            }
            else if (this.showBusyCursor && !this._isbusy)
            {
                this._isbusy = true;
                CursorManager.setBusyCursor();
            }
         }
         
         protected function get respondercounter ():int
         {
            return this._respondercounter;
         }
    }
}
internal class AbstractRestriction
{
        
}

package com.dougmccune.coverflow
{
    import caurina.transitions.Tweener;
    
    import com.dougmccune.coverflow.materials.ReflectionMaterial;
    
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.events.TimerEvent;
    import flash.geom.ColorTransform;
    import flash.utils.Dictionary;
    import flash.utils.Timer;
    
    import mx.containers.ViewStack;
    import mx.core.ContainerCreationPolicy;
    import mx.core.EdgeMetrics;
    import mx.core.UIComponent;
    
    import org.papervision3d.Papervision3D;
    import org.papervision3d.cameras.Camera3D;
    import org.papervision3d.materials.MovieMaterial;
    import org.papervision3d.objects.Plane;
    import org.papervision3d.scenes.MovieScene3D;
    import org.papervision3d.scenes.Scene3D;
    import mx.core.mx_internal;
    
    use namespace mx_internal;
    
    [Style(name="horizontalSpacing", type="Number", format="Length", inherit="no")]
    [Style(name="verticalSpacing", type="Number", format="Length", inherit="no")]
    
    public class CoverFlowContainer extends ViewStack
    {
        /**
         * The time for each tween. Setting this lower will make the animations faster (but maybe choppier if the
         * CPU can't keep up).
         */
        public var tweenDuration:Number = 1;
        
        /**
         * If true the Planes near the edge of the component will fade to transparent. Kind of a cool effect sometimes
         * if you want it.
         */
        public var fadeEdges:Boolean = false;
        
        /**
         * Is the reflection enabled? If so we create two 3D planes for each child. This effectively means that
         * PaperVision has to render twice as many polygons if you enable the reflection, whch will slow performance. 
         * But it looks nice.
         */
        public var reflectionEnabled:Boolean = false;
        
        /**
         * The number of segments used for the PaperVision Planes that are created. The lower the number the better
         * the performance, but you'll notice distortion in your images when they are rotated. For some types of images 
         * a value as low as 1 or 2 will work fine, but for things wil horizontal lines or text, you'll have to go higher.
         */
        public var segments:Number = 6;
        
        /**
         * The angle that each Plane is rotated on the y axis. This corresponds to PaperVision's yRotation property on
         * the Plane. This is in degrees and should range from 0-90. A value of 0 means no rotation is applied and a value of 90
         * would mean the Plane is rotated so much that it would effectively disappear.
         */
        public var rotationAngle:Number = 70;
        
        /**
         * @private
         * 
         * We're going to have a sprite that contains our PV3D scene added to the
         * display list, which falls outside of the stuff that gets clipped normally by
         * the container. So if we want to clip the content like you would expect from a 
         * Container then we have to do our own clipping.
         */
        private var clippingMask:Sprite;
        
        /**
         * @private
         * 
         * This is the main Sprite that will get rendered with our 3D scene.
         */
        private var pv3dSprite:Sprite;
        
        /**
         * @private
         * 
         * The Scene3D that PaperVision will render. This will get rendered to the pv3dSprite object.
         */
        private var scene:Scene3D;
        
        /**
         * @private
         * 
         * The Camera3D object that controls how we render the scene.
         */
        private var camera:Camera3D;
        
        /**
         * @private
         * 
         * A Dictionary we'll use to store a reference to the Plane object we create. The key will be the DisplayObject and the
         * value will be the Plane, that way we can take any child DIsplayObject and look up the 3D Plane.
         */
        private var objectsToPlanes:Dictionary;
        
        /**
         * @private
         * 
         * Same thing for the reflection Planes. Gotta be able to take any DIsplayObject and look up the reflection
         * for that object.
         */
        private var objectsToReflections:Dictionary;
        
        /**
         * @private
         * 
         * We want to detect clicks on the 3D Planes, but we don't want to use the complex interactivity crap in PV3D.
         * (It's not actually crap, it's awesome, but it's slow). So instead, since we're using a MovieScene3D, we can 
         * simply access the container proeprty of any 3D object to get access to the DisplayObjec that it is in. Then
         * we can use this container for our mouse click detection. So we need to be able take any of those container DIsplayObjects
         * and look up the original child that it's associated with.
         */
        private var containersToObjects:Dictionary;
        
        /**
         * @private
         * 
         * For some of the layout stuff we need to know the max height of all the children. As children are
         * added we make sure to update maxChildHeight.
         */
        private var maxChildHeight:Number;
        
        /**
         * @private
         * 
         * When the 3D transition is complete and the selected child faces the user face on, then we want to substitute
         * the real child in it's place, so that the user can interact with it. To do this we use a timer that gets reset 
         * everytime a tween is started. Then once the tween has successfully completed, which means the selected child is
         * directly facing the user, we do the old switcheroo.
         */
        private var timer:Timer;
        
        public function CoverFlowContainer():void {
            super();
            
            //since we need to show all the children we have to make sure that
            //creationPolicy is set to all. Otherwise the other non-selected 
            //children would be blank until they were selected and that would look lame.
            this.creationPolicy = ContainerCreationPolicy.ALL;
            
            //crate our dictionaries, using weak keys
            objectsToPlanes = new Dictionary(true);
            objectsToReflections = new Dictionary(true);
            containersToObjects = new Dictionary(true);
            
            timer = new Timer(tweenDuration*1000, 1);
            timer.addEventListener(TimerEvent.TIMER_COMPLETE, timerComplete);
            
            pv3dSprite = new Sprite();
            setupScene();
        }
        
        override protected function createChildren():void {
            super.createChildren();
            
            clippingMask = new Sprite();
            rawChildren.addChild(clippingMask);
            
            rawChildren.addChildAt(pv3dSprite, 0);
            
            //we're just going to render the 3D scene on every frame
            this.addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }
        
        
        
        
        
        private function setupScene():void {
            //turn off the debugging trace statements for PV3D
            Papervision3D.VERBOSE = false;
            
            //create a new MovieScene3D and tell it to draw to pv3dSprite
            scene = new MovieScene3D(pv3dSprite);
            
            //create a new Camera3D
            camera = new Camera3D();
            camera.z = -200;
        }
        
        private function enterFrameHandler(event:Event):void {
            try {
                scene.renderCamera(camera);
            }
            catch(e:Error) { }
        }
        
        override public function addChild(child:DisplayObject):DisplayObject {
            var child:DisplayObject = super.addChild(child);
            
            if(reflectionEnabled) {
                var reflMaterial:MovieMaterial = new ReflectionMaterial(child);
                
                var reflection:Plane = new Plane(reflMaterial, child.width, child.height, segments, segments);
                scene.addChild(reflection);
                
                objectsToReflections[child] = reflection;
            }
        
            var material:MovieMaterial = new MovieMaterial(child, true, true);
            material.smooth = true;
            
            var plane:Plane = new Plane(material, child.width, child.height, segments, segments);   
            scene.addChild(plane);
            
            containersToObjects[plane.container] = child;
            
            //once the Plane is added to the scene we can access the container property, whcih we use to handle
            //mouse clicks
            plane.container.addEventListener(MouseEvent.CLICK, containerClicked);
            
            objectsToPlanes[child] = plane;
            
            if(isNaN(maxChildHeight) || child.height > maxChildHeight) {
                maxChildHeight = child.height;
            }
            
            return child;
        }
        
        private function containerClicked(event:MouseEvent):void {
            var child:DisplayObject = containersToObjects[event.currentTarget];
            
            var index:int = getChildIndex(child);
            selectedIndex = index;
        }
        
        /**
         * Whenever we remove a child we also remove the planes that we had created for it.
         */
        override public function removeChild(child:DisplayObject):DisplayObject {
            var plane:Plane = objectsToPlanes[child];
            
            scene.removeChild(plane);
            
            if(reflectionEnabled) {
                var refl:Plane = objectsToReflections[child];
                scene.removeChild(refl);
            }
            
            return super.removeChild(child);
        }
        
        
        override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void {
            super.updateDisplayList(unscaledWidth, unscaledHeight);
            
            //sometimes our child ordering gets jacked. Make sure our pv3d sprite is below the actual children
            //which is important once we show the real child display object
            if(rawChildren.contains(pv3dSprite)) {
                if(border) {
                    rawChildren.setChildIndex(pv3dSprite, 0);
                    rawChildren.setChildIndex(DisplayObject(border), 0);
                }
                else {
                    rawChildren.setChildIndex(pv3dSprite, 0);
                }
            }
            
            clippingMask.graphics.clear();
            
            if(clipContent) {
                clippingMask.graphics.beginFill(0x000000);
                clippingMask.graphics.drawRect(0,0, unscaledWidth, unscaledHeight);
                pv3dSprite.mask = clippingMask;
            }
            
            pv3dSprite.y = unscaledHeight/2;
            pv3dSprite.x = unscaledWidth/2;
            
            var n:int = numChildren;
            
            for(var i:int=0; i<n; i++) {
                var child:DisplayObject = getChildAt(i);
                var plane:Plane = objectsToPlanes[child];
                plane.container.visible = true;
                
                var abs:Number = Math.abs(selectedIndex - i);
                
                var horizontalGap:Number = getStyle("horizontalSpacing");
                if(isNaN(horizontalGap)) {
                    //this seems to work fairly well as a default
                    horizontalGap = maxChildHeight/3;
                }
                
                var verticalGap:Number = getStyle("verticalSpacing");
                if(isNaN(verticalGap)) {
                    verticalGap = 10;
                }
                
                var xPosition:Number = selectedChild.width + ((abs-1) * horizontalGap);
                var yPosition:Number = -(maxChildHeight - child.height)/2;
                var zPosition:Number = camera.z/2 + selectedChild.width + abs * verticalGap;
                
                var yRotation:Number = rotationAngle;
                
                //some kinda fuzzy math here, I dunno, I was just playing with values
                //note that this only gets used if fadeEdges is true below
                var alpha:Number = (unscaledWidth/2 - xPosition) / (unscaledWidth/2);
                alpha  = Math.max(Math.min(alpha*2, 1), 0);
                
                if(i < selectedIndex) {
                    xPosition *= -1;
                    yRotation *= -1;
                }
                else if(i==selectedIndex) {
                    xPosition = 0;
                    zPosition = camera.z/2;
                    yRotation = 0;
                    alpha = 1;
                }
                
                if(fadeEdges) {
                    //here's something sneaky. PV3D applies the colorTransform of the source movie clip to the
                    //bitmapData that's created. So if we adjust the colorTransform that will be shown in the
                    //3D plane as well. Cool, huh? Only works for animated materials (or you could call update
                    //on the material manually)
                    var colorTransform:ColorTransform  = child.transform.colorTransform;
                    colorTransform.alphaMultiplier = alpha;
                    child.transform.colorTransform = colorTransform;
                }
                
                if(reflectionEnabled) {
                    var reflection:Plane = objectsToReflections[child];
                    
                    //drop the reflection down below the plane and put in a gap of 2 pixels. Why 2 pixels? I think it looks nice.
                    reflection.y = yPosition - child.height - 2;
                    Tweener.addTween(reflection, {x:xPosition, z:zPosition, rotationY:yRotation, time:tweenDuration});
                    
                    if(fadeEdges) {
                        Tweener.addTween(reflection.container, {alpha:alpha, time:tweenDuration});
                    }
                }
                
                Tweener.addTween(plane, {x:xPosition, z:zPosition, y:yPosition, rotationY:yRotation, time:tweenDuration});
                
                if(i == selectedIndex) {
                    var bm:EdgeMetrics = borderMetrics;
        
                    //We need to adjust the location of the selected child so
                    //it exactly lines up with where our 3D plane will be. 
                    child.x = unscaledWidth/2 - child.width/2 - bm.top;
                    child.y = unscaledHeight/2 - child.height/2 - yPosition - bm.left;
                    
                    //the normal ViewStack sets the visibility of the selectedChild. That's no good for us,
                    //so we just reset it back. 
                    child.visible = false;
                }
            }
            
            if(timer.running) {
                timer.reset();
            }
            
            timer.start();
            
        }
        
        private function timerComplete(event:TimerEvent):void {
            showVisibleChild();
        }
        
        private function showVisibleChild():void {
            if(selectedChild != null) {
                selectedChild.visible = true;
                
                var plane:Plane = objectsToPlanes[selectedChild];
                plane.container.visible = false;
                
                if(border) {
                    
                    rawChildren.setChildIndex(pv3dSprite, 0);
                    rawChildren.setChildIndex(DisplayObject(border), 0);
                }
                else {
                    rawChildren.setChildIndex(pv3dSprite, 0);
                }
            }
        }
    }
}