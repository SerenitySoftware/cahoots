package org.jamesward.bubblemark
{
  import flash.display.Graphics;
  
  import mx.core.IFactory;
  import mx.core.UIComponent;
  
    public class Ball extends UIComponent {
        
        public var vx:Number = 0;
        public var vy:Number = 0;
        public var d:Number;
        public var d2:Number;       
        
    public var radius:Number;
    public var maxSpeed:Number;
    public var elastity:Number;
    public var renderer:IFactory;
    
        public function Ball() {
      radius = 26;
      maxSpeed = 3;
      elastity = -0.2;
      
            d = 2*radius;
            d2 = d*d;
        }
        
        override protected function createChildren():void
        {
          super.createChildren();
          
          if (renderer != null)
          {
            this.addChild(renderer.newInstance());
          }
          else
          {
            var g:Graphics = graphics;
              g.beginFill(0x0000ff);
              g.drawCircle(26,26,26);
              g.endFill();
            }
        }

    }

}


/**
 * Copyright (c) 2007, Akeem Philbert (based on the work of (between others): Jesse Warden, Xavi Beumala, Renaun 
  Erickson, Carlos Rovira)
  All rights reserved.
*/

package com.ak33m.rpc.xmlrpc
{
  import mx.utils.Base64Encoder;
  import flash.utils.ByteArray;
  import mx.formatters.DateFormatter;
  import mx.utils.Base64Decoder;
  import mx.rpc.Fault;
  import com.ak33m.rpc.core.RPCMessageCodes;
  import flash.xml.XMLNode;
  import flash.xml.XMLDocument;
  
  public class XMLRPCSerializer
  {
    internal static const TYPE_INT:String = "int";
    internal static const TYPE_I4:String = "i4";
    internal static const TYPE_DOUBLE:String = "double";
    internal static const TYPE_STRING:String = "string";
    internal static const TYPE_BOOLEAN:String = "boolean";
    internal static const TYPE_ARRAY:String = "array";
    internal static const TYPE_BASE64:String = "base64";
    internal static const TYPE_STRUCT:String = "struct";
    internal static const TYPE_DATE:String = "dateTime.iso8601";
    
    public function XMLRPCSerializer ()
    {
      
    }
    
    public static function serialize (method:String,params:Array):XML
    {
      var xmlrpc:XML = <methodCall>
                <methodName>{method}</methodName>
               </methodCall>
      if (params.length > 0)
      {
        var tparams:XML = <params></params>
        for each (var param:* in params)
        {
          tparams.appendChild(<param><value>{encodeObject(param)}</value></param>);
        }
        xmlrpc.insertChildAfter(xmlrpc.methodName,tparams);
      }
      
      return xmlrpc;    
    }
    
    protected static function encodeObject (tobject:*):XMLList
    {
      var txmllist:XMLList;
      if (tobject is String)
      {
        txmllist =  encodeString(tobject);
      }
      else if (tobject is Number && Math.floor(tobject)==tobject)
      {
        txmllist =  encodeInteger(tobject);
      }
      else if (tobject is Boolean)
      {
        txmllist =  encodeBoolean(tobject);
      }
      else if (tobject is Number)
      {
        txmllist =  encodeDouble(tobject);
      }
      else if (tobject is Date)
      {
        txmllist =  encodeDate(tobject);
      }
      else if (tobject is Array)
      {
        txmllist =  encodeArray(tobject);
      }
      else if (tobject is IXMLRPCStruct)
      {
        txmllist =  encodeStruct(tobject.getPropertyData());
      }
      else
      {
        txmllist = encodeString(tobject as String);
      }
      
      return txmllist;
    }
    
    protected static function encodeString(rstring:String):XMLList
    {
      return new XMLList("<"+TYPE_STRING+">"+rstring+"</"+TYPE_STRING+">");
    }
    
    protected static function encodeBoolean (rboolean:Boolean):XMLList
    {
      var xmlrpcboolean:String = rboolean ? "1" : "0";
      return new XMLList("<"+TYPE_BOOLEAN+">"+xmlrpcboolean+"</"+TYPE_BOOLEAN+">");
    }
    
    protected static function encodeInteger (rinteger:int):XMLList
    {
      return new XMLList("<"+TYPE_INT+">"+rinteger+"</"+TYPE_INT+">");
    }
    
    protected static function encodeDouble (rdouble:Number):XMLList
    {
      return new XMLList("<"+TYPE_DOUBLE+">"+rdouble+"</"+TYPE_DOUBLE+">");
    }
    
    protected static function encodeDate (rdate:Date):XMLList
    {
      var tdateformatter:DateFormatter = new DateFormatter();
      tdateformatter.formatString = "YYYYMMDDTJJ:NN:SS";
      var tdatestring:String = tdateformatter.format(rdate);
      return new XMLList("<"+TYPE_DATE+">"+tdatestring+"</"+TYPE_DATE+">");
    }
    
    protected static function encodeArray (rarray:Array):XMLList
    {
      var tarrayxml:XML = <array>
                </array>
      var tarraydataxml:XML = <data>
                  </data>
      for (var i:int; i<rarray.length; i++)
      {
        tarraydataxml.appendChild(<value>{encodeObject(rarray[i])}</value>);
      }
      tarrayxml.appendChild(tarraydataxml);
      return new XMLList(tarrayxml);
    }
    
    protected static function encodeBase64 (rbase64:ByteArray):XMLList
    {
      var enc:Base64Encoder = new Base64Encoder();
      enc.encodeBytes(rbase64);
      return new XMLList("<"+TYPE_BASE64+">"+enc.drain()+"</"+TYPE_BASE64+">");
    }
    
    protected static function encodeStruct (rprops:*):XMLList
    {
      var tstructxml:XML = <struct>
                 </struct>
      for (var j:* in rprops)
      {
        tstructxml.appendChild(<member><name>{j}</name><value>{encodeObject(rprops[j])}</value></member>);
      }
      return new XMLList(tstructxml);
    }
    
    public static function deserialize (rxmlresult:XMLDocument):*
    {
      var xmlresult:XML = new XML(rxmlresult.toString());
      var resultvaluexml:XMLList = xmlresult.params.param.value;
      var faultxml:XMLList = xmlresult.fault.value;
      if (resultvaluexml.toString() != "")
      return decodeObject(resultvaluexml);
      else if (faultxml)
      {
        var faultobj:* = decodeObject(faultxml);
        var tfault:Fault = new Fault(faultobj.faultCode,faultobj.faultString);
        return tfault;
      }
      else
      {
        throw new Error(RPCMessageCodes.INVALID_XMLRPCFORMAT);
      }
    }
    
    protected static function decodeObject (robject:*):*
    {
      if (robject.children().name() == TYPE_STRING)
      {
        return String(robject.string);
      }
      else if (robject.children().name() == TYPE_INT)
      {
        return new int(robject.int);
      }
      else if (robject.children().name() == TYPE_I4)
      {
        return new int (robject.i4);
      }
      else if (robject.children().name() == TYPE_BOOLEAN)
      {
        if (isNaN(robject.boolean))
        {
          if (String(robject.boolean).toLowerCase() == "true")
          return true;
          else if (String(robject.boolean).toLowerCase() == "false")
          return false;
          else
          return null;
        }
        else
        {
          return Boolean(Number(robject.boolean));
        }
      }
      else if (robject.children().name()== TYPE_DATE)
      {
        var tdatestring:String = robject.children();
        var datepattern:RegExp = /^(-?\d\d\d\d)-?(\d\d)-?(\d\d)T(\d\d):(\d\d):(\d\d)/;
        var d:Array = tdatestring.match(datepattern);
        var tdate:Date =  new Date(d[1],d[2]-1,d[3],d[4],d[5],d[6]);
        return tdate;
      }
      else if (robject.children().name() == TYPE_BASE64)
      {
        var base64decoder:Base64Decoder = new Base64Decoder();
        base64decoder.decode(robject.base64);
        return base64decoder.flush();
        
      }
      else if (robject.children().name() == TYPE_ARRAY)
      {
        var tarray:Array = new Array();
        for each (var value:* in robject.array.data.value)
        {
          tarray.push(decodeObject(value));
        }
        return tarray;
      }
      else if (robject.children().name() == TYPE_STRUCT)
      {
        var tvalue:Object = new Object();
        for each (var member:* in robject.struct.member)
        {
          tvalue[member.name] = decodeObject(member.value);
        }
        return tvalue;
      }
      else if (robject.children().name() == TYPE_DOUBLE)
      {
        return Number(robject.double);
      }
      else 
      {
        return String(robject);
      }
    }
  }
}

/*********************************************************************************************************************************
 
 Copyright (c) 2007 Ben Stucki
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
 modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
*********************************************************************************************************************************/
package com.benstucki.utilities
{
  import flash.display.BitmapData;
  import flash.display.Loader;
  import flash.display.LoaderInfo;
  import flash.events.Event;
  import flash.geom.Matrix;
  import flash.net.URLRequest;
  import flash.system.LoaderContext;
  import flash.utils.Dictionary;
  
  import mx.containers.accordionClasses.AccordionHeader;
  import mx.controls.tabBarClasses.Tab;
  import mx.core.BitmapAsset;
  import mx.core.UIComponent;
  
  /**
   * Provides a workaround for using run-time loaded graphics in styles and properties which require a Class reference
   */
  public class IconUtility extends BitmapAsset
  {
    
    private static var dictionary:Dictionary;
    
    /**
     * Used to associate run-time graphics with a target
     * @param target A reference to the component associated with this icon
     * @param source A url to a JPG, PNG or GIF file you wish to be loaded and displayed
     * @param width Defines the width of the graphic when displayed
     * @param height Defines the height of the graphic when displayed
     * @return A reference to the IconUtility class which may be treated as a BitmapAsset
     * @example &lt;mx:Button id="button" icon="{IconUtility.getClass(button, 'http://www.yourdomain.com/images/test.jpg')}" /&gt;
     */
    public static function getClass( target:UIComponent, source:String, width:Number = NaN, height:Number = NaN ):Class {
      if(!dictionary) {
        dictionary = new Dictionary(false);
      }
      //if(source is String) {
        var loader:Loader = new Loader();
        loader.load(new URLRequest(source as String), new LoaderContext(true));
        //source = loader;
      //}
      dictionary[target] = { source:loader, width:width, height:height };
      return IconUtility;
    }
    
    /**
     * @private
     */
    public function IconUtility():void {
      addEventListener(Event.ADDED, addedHandler, false, 0, true)
    }
    
    private function addedHandler(event:Event):void {
      if(parent) {
        if(parent is AccordionHeader) {
          var header:AccordionHeader = parent as AccordionHeader;
          getData(header.data);
        } else if(parent is Tab) {
          var tab:Tab = parent as Tab;
          getData(tab.data);
        } else {
          getData(parent);
        }
      }
    }
    
    private function getData(object:Object):void {
      var data:Object = dictionary[object];
      if(data) {
        var source:Object = data.source;
        if(data.width > 0 && data.height > 0) {
          bitmapData = new BitmapData(data.width, data.height, true, 0x00FFFFFF);
        }
        if(source is Loader) {
          var loader:Loader = source as Loader;
          if(!loader.content) {
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler, false, 0, true);
          } else {
            displayLoader(loader);
          }
        }
      }
    }
    
    private function displayLoader( loader:Loader ):void {
      if(!bitmapData) {
        bitmapData = new BitmapData(loader.content.width, loader.content.height, true, 0x00FFFFFF);
      }
      bitmapData.draw(loader, new Matrix(bitmapData.width/loader.width, 0, 0, bitmapData.height/loader.height, 0, 0));
      if(parent is UIComponent) {
        var component:UIComponent = parent as UIComponent;
        component.invalidateSize();
      }
    }
    
    private function completeHandler(event:Event):void {
      if(event && event.target && event.target is LoaderInfo) {
        displayLoader(event.target.loader as Loader);
      }
    }
    
  }
}