package com.dougmccune.coverflow
{
    import caurina.transitions.Tweener;
    
    import com.dougmccune.coverflow.materials.ReflectionMaterial;
    
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.events.TimerEvent;
    import flash.geom.ColorTransform;
    import flash.utils.Dictionary;
    import flash.utils.Timer;
    
    import mx.containers.ViewStack;
    import mx.core.ContainerCreationPolicy;
    import mx.core.EdgeMetrics;
    import mx.core.UIComponent;
    
    import org.papervision3d.Papervision3D;
    import org.papervision3d.cameras.Camera3D;
    import org.papervision3d.materials.MovieMaterial;
    import org.papervision3d.objects.Plane;
    import org.papervision3d.scenes.MovieScene3D;
    import org.papervision3d.scenes.Scene3D;
    import mx.core.mx_internal;
    
    use namespace mx_internal;
    
    [Style(name="horizontalSpacing", type="Number", format="Length", inherit="no")]
    [Style(name="verticalSpacing", type="Number", format="Length", inherit="no")]
    
    public class CoverFlowContainer extends ViewStack
    {
        /**
         * The time for each tween. Setting this lower will make the animations faster (but maybe choppier if the
         * CPU can't keep up).
         */
        public var tweenDuration:Number = 1;
        
        /**
         * If true the Planes near the edge of the component will fade to transparent. Kind of a cool effect sometimes
         * if you want it.
         */
        public var fadeEdges:Boolean = false;
        
        /**
         * Is the reflection enabled? If so we create two 3D planes for each child. This effectively means that
         * PaperVision has to render twice as many polygons if you enable the reflection, whch will slow performance. 
         * But it looks nice.
         */
        public var reflectionEnabled:Boolean = false;
        
        /**
         * The number of segments used for the PaperVision Planes that are created. The lower the number the better
         * the performance, but you'll notice distortion in your images when they are rotated. For some types of images 
         * a value as low as 1 or 2 will work fine, but for things wil horizontal lines or text, you'll have to go higher.
         */
        public var segments:Number = 6;
        
        /**
         * The angle that each Plane is rotated on the y axis. This corresponds to PaperVision's yRotation property on
         * the Plane. This is in degrees and should range from 0-90. A value of 0 means no rotation is applied and a value of 90
         * would mean the Plane is rotated so much that it would effectively disappear.
         */
        public var rotationAngle:Number = 70;
        
        /**
         * @private
         * 
         * We're going to have a sprite that contains our PV3D scene added to the
         * display list, which falls outside of the stuff that gets clipped normally by
         * the container. So if we want to clip the content like you would expect from a 
         * Container then we have to do our own clipping.
         */
        private var clippingMask:Sprite;
        
        /**
         * @private
         * 
         * This is the main Sprite that will get rendered with our 3D scene.
         */
        private var pv3dSprite:Sprite;
        
        /**
         * @private
         * 
         * The Scene3D that PaperVision will render. This will get rendered to the pv3dSprite object.
         */
        private var scene:Scene3D;
        
        /**
         * @private
         * 
         * The Camera3D object that controls how we render the scene.
         */
        private var camera:Camera3D;
        
        /**
         * @private
         * 
         * A Dictionary we'll use to store a reference to the Plane object we create. The key will be the DisplayObject and the
         * value will be the Plane, that way we can take any child DIsplayObject and look up the 3D Plane.
         */
        private var objectsToPlanes:Dictionary;
        
        /**
         * @private
         * 
         * Same thing for the reflection Planes. Gotta be able to take any DIsplayObject and look up the reflection
         * for that object.
         */
        private var objectsToReflections:Dictionary;
        
        /**
         * @private
         * 
         * We want to detect clicks on the 3D Planes, but we don't want to use the complex interactivity crap in PV3D.
         * (It's not actually crap, it's awesome, but it's slow). So instead, since we're using a MovieScene3D, we can 
         * simply access the container proeprty of any 3D object to get access to the DisplayObjec that it is in. Then
         * we can use this container for our mouse click detection. So we need to be able take any of those container DIsplayObjects
         * and look up the original child that it's associated with.
         */
        private var containersToObjects:Dictionary;
        
        /**
         * @private
         * 
         * For some of the layout stuff we need to know the max height of all the children. As children are
         * added we make sure to update maxChildHeight.
         */
        private var maxChildHeight:Number;
        
        /**
         * @private
         * 
         * When the 3D transition is complete and the selected child faces the user face on, then we want to substitute
         * the real child in it's place, so that the user can interact with it. To do this we use a timer that gets reset 
         * everytime a tween is started. Then once the tween has successfully completed, which means the selected child is
         * directly facing the user, we do the old switcheroo.
         */
        private var timer:Timer;
        
        public function CoverFlowContainer():void {
            super();
            
            //since we need to show all the children we have to make sure that
            //creationPolicy is set to all. Otherwise the other non-selected 
            //children would be blank until they were selected and that would look lame.
            this.creationPolicy = ContainerCreationPolicy.ALL;
            
            //crate our dictionaries, using weak keys
            objectsToPlanes = new Dictionary(true);
            objectsToReflections = new Dictionary(true);
            containersToObjects = new Dictionary(true);
            
            timer = new Timer(tweenDuration*1000, 1);
            timer.addEventListener(TimerEvent.TIMER_COMPLETE, timerComplete);
            
            pv3dSprite = new Sprite();
            setupScene();
        }
        
        override protected function createChildren():void {
            super.createChildren();
            
            clippingMask = new Sprite();
            rawChildren.addChild(clippingMask);
            
            rawChildren.addChildAt(pv3dSprite, 0);
            
            //we're just going to render the 3D scene on every frame
            this.addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }
        
        
        
        
        
        private function setupScene():void {
            //turn off the debugging trace statements for PV3D
            Papervision3D.VERBOSE = false;
            
            //create a new MovieScene3D and tell it to draw to pv3dSprite
            scene = new MovieScene3D(pv3dSprite);
            
            //create a new Camera3D
            camera = new Camera3D();
            camera.z = -200;
        }
        
        private function enterFrameHandler(event:Event):void {
            try {
                scene.renderCamera(camera);
            }
            catch(e:Error) { }
        }
        
        override public function addChild(child:DisplayObject):DisplayObject {
            var child:DisplayObject = super.addChild(child);
            
            if(reflectionEnabled) {
                var reflMaterial:MovieMaterial = new ReflectionMaterial(child);
                
                var reflection:Plane = new Plane(reflMaterial, child.width, child.height, segments, segments);
                scene.addChild(reflection);
                
                objectsToReflections[child] = reflection;
            }
        
            var material:MovieMaterial = new MovieMaterial(child, true, true);
            material.smooth = true;
            
            var plane:Plane = new Plane(material, child.width, child.height, segments, segments);   
            scene.addChild(plane);
            
            containersToObjects[plane.container] = child;
            
            //once the Plane is added to the scene we can access the container property, whcih we use to handle
            //mouse clicks
            plane.container.addEventListener(MouseEvent.CLICK, containerClicked);
            
            objectsToPlanes[child] = plane;
            
            if(isNaN(maxChildHeight) || child.height > maxChildHeight) {
                maxChildHeight = child.height;
            }
            
            return child;
        }
        
        private function containerClicked(event:MouseEvent):void {
            var child:DisplayObject = containersToObjects[event.currentTarget];
            
            var index:int = getChildIndex(child);
            selectedIndex = index;
        }
        
        /**
         * Whenever we remove a child we also remove the planes that we had created for it.
         */
        override public function removeChild(child:DisplayObject):DisplayObject {
            var plane:Plane = objectsToPlanes[child];
            
            scene.removeChild(plane);
            
            if(reflectionEnabled) {
                var refl:Plane = objectsToReflections[child];
                scene.removeChild(refl);
            }
            
            return super.removeChild(child);
        }
        
        
        override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void {
            super.updateDisplayList(unscaledWidth, unscaledHeight);
            
            //sometimes our child ordering gets jacked. Make sure our pv3d sprite is below the actual children
            //which is important once we show the real child display object
            if(rawChildren.contains(pv3dSprite)) {
                if(border) {
                    rawChildren.setChildIndex(pv3dSprite, 0);
                    rawChildren.setChildIndex(DisplayObject(border), 0);
                }
                else {
                    rawChildren.setChildIndex(pv3dSprite, 0);
                }
            }
            
            clippingMask.graphics.clear();
            
            if(clipContent) {
                clippingMask.graphics.beginFill(0x000000);
                clippingMask.graphics.drawRect(0,0, unscaledWidth, unscaledHeight);
                pv3dSprite.mask = clippingMask;
            }
            
            pv3dSprite.y = unscaledHeight/2;
            pv3dSprite.x = unscaledWidth/2;
            
            var n:int = numChildren;
            
            for(var i:int=0; i<n; i++) {
                var child:DisplayObject = getChildAt(i);
                var plane:Plane = objectsToPlanes[child];
                plane.container.visible = true;
                
                var abs:Number = Math.abs(selectedIndex - i);
                
                var horizontalGap:Number = getStyle("horizontalSpacing");
                if(isNaN(horizontalGap)) {
                    //this seems to work fairly well as a default
                    horizontalGap = maxChildHeight/3;
                }
                
                var verticalGap:Number = getStyle("verticalSpacing");
                if(isNaN(verticalGap)) {
                    verticalGap = 10;
                }
                
                var xPosition:Number = selectedChild.width + ((abs-1) * horizontalGap);
                var yPosition:Number = -(maxChildHeight - child.height)/2;
                var zPosition:Number = camera.z/2 + selectedChild.width + abs * verticalGap;
                
                var yRotation:Number = rotationAngle;
                
                //some kinda fuzzy math here, I dunno, I was just playing with values
                //note that this only gets used if fadeEdges is true below
                var alpha:Number = (unscaledWidth/2 - xPosition) / (unscaledWidth/2);
                alpha  = Math.max(Math.min(alpha*2, 1), 0);
                
                if(i < selectedIndex) {
                    xPosition *= -1;
                    yRotation *= -1;
                }
                else if(i==selectedIndex) {
                    xPosition = 0;
                    zPosition = camera.z/2;
                    yRotation = 0;
                    alpha = 1;
                }
                
                if(fadeEdges) {
                    //here's something sneaky. PV3D applies the colorTransform of the source movie clip to the
                    //bitmapData that's created. So if we adjust the colorTransform that will be shown in the
                    //3D plane as well. Cool, huh? Only works for animated materials (or you could call update
                    //on the material manually)
                    var colorTransform:ColorTransform  = child.transform.colorTransform;
                    colorTransform.alphaMultiplier = alpha;
                    child.transform.colorTransform = colorTransform;
                }
                
                if(reflectionEnabled) {
                    var reflection:Plane = objectsToReflections[child];
                    
                    //drop the reflection down below the plane and put in a gap of 2 pixels. Why 2 pixels? I think it looks nice.
                    reflection.y = yPosition - child.height - 2;
                    Tweener.addTween(reflection, {x:xPosition, z:zPosition, rotationY:yRotation, time:tweenDuration});
                    
                    if(fadeEdges) {
                        Tweener.addTween(reflection.container, {alpha:alpha, time:tweenDuration});
                    }
                }
                
                Tweener.addTween(plane, {x:xPosition, z:zPosition, y:yPosition, rotationY:yRotation, time:tweenDuration});
                
                if(i == selectedIndex) {
                    var bm:EdgeMetrics = borderMetrics;
        
                    //We need to adjust the location of the selected child so
                    //it exactly lines up with where our 3D plane will be. 
                    child.x = unscaledWidth/2 - child.width/2 - bm.top;
                    child.y = unscaledHeight/2 - child.height/2 - yPosition - bm.left;
                    
                    //the normal ViewStack sets the visibility of the selectedChild. That's no good for us,
                    //so we just reset it back. 
                    child.visible = false;
                }
            }
            
            if(timer.running) {
                timer.reset();
            }
            
            timer.start();
            
        }
        
        private function timerComplete(event:TimerEvent):void {
            showVisibleChild();
        }
        
        private function showVisibleChild():void {
            if(selectedChild != null) {
                selectedChild.visible = true;
                
                var plane:Plane = objectsToPlanes[selectedChild];
                plane.container.visible = false;
                
                if(border) {
                    
                    rawChildren.setChildIndex(pv3dSprite, 0);
                    rawChildren.setChildIndex(DisplayObject(border), 0);
                }
                else {
                    rawChildren.setChildIndex(pv3dSprite, 0);
                }
            }
        }
    }
}